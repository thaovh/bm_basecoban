---
alwaysApply: true
---
QUY ƯỚC PHÁT TRIỂN PHẦN MỀM (TypeScript, NestJS, CQRS, TypeORM)
1. Nguyên Tắc Kiến Trúc Cốt Lõi
Quy tắc này ưu tiên Khả năng Bảo trì (Maintainability), Khả năng Kiểm thử (Testability), và Khả năng Mở rộng (Scalability) bằng cách áp dụng Clean Architecture và Domain-Driven Design (DDD).

Tách biệt Trách nhiệm (Separation of Concerns): Phân chia rõ ràng logic nghiệp vụ (Application Layer) khỏi các chi tiết kỹ thuật (Infrastructure Layer).

Dependency Inversion Principle (DIP): Lớp cấp cao không được phụ thuộc vào lớp cấp thấp. Cả hai đều phải phụ thuộc vào Abstraction (TypeScript Interfaces hoặc Abstract Classes).

Dependency Injection (DI): Luôn tận dụng hệ thống DI của NestJS. Không sử dụng từ khóa new để tạo dependencies (ngoại trừ Domain Entities thuần túy).

CQRS: Tách biệt triệt để mô hình Ghi (Write Model - Commands) và Đọc (Read Model - Queries) để tối ưu hóa hiệu suất và sự phức tạp của nghiệp vụ.

2. Cấu Trúc Thư Mục Dự Án (Folder Structure)
Cấu trúc dự án tuân thủ mô hình Feature-Based Modules của NestJS, nơi mỗi module được phân lớp theo kiến trúc sạch (Clean Architecture) và CQRS.

src/
├── app.module.ts                   // Module gốc
├── main.ts                         // Khởi động ứng dụng

├── common/                         // Thư viện, tiện ích dùng chung (Exceptions, Filters, Decorators)
│   ├── filters/
│   │   └── exception.filter.ts     // Global Exception Filter
│   ├── interceptors/
│   └── dtos/

├── modules/                        // 💡 TỔ CHỨC THEO TÍNH NĂNG (Feature Modules)
│   ├── user/
│   │   ├── user.module.ts          // Gói tất cả thành phần của tính năng "User"
│   │   ├── user.controller.ts      // INTERFACE ADAPTERS (HTTP Handlers)
│   │   ├── domain/                 // 1. DOMAIN LAYER
│   │   │   ├── user.entity.ts      // Domain Model (TypeORM Entity)
│   │   │   └── user.interface.ts   // Interface định nghĩa các quy tắc của Entity
│   │   ├── application/            // 2. APPLICATION LAYER (Use Cases/Business Logic)
│   │   │   ├── commands/           // 2a. WRITE LOGIC (CQRS - Commands)
│   │   │   │   ├── impl/           // Command Handlers (sửa đổi trạng thái)
│   │   │   │   │   └── create-user.handler.ts
│   │   │   │   ├── create-user.command.ts // Command DTO
│   │   │   │   └── create-user.dto.ts     // Request DTO cho Command
│   │   │   ├── queries/            // 2b. READ LOGIC (CQRS - Queries)
│   │   │   │   ├── impl/
│   │   │   │   │   └── get-user-by-id.handler.ts
│   │   │   │   ├── get-user-by-id.query.ts  // Query DTO
│   │   │   │   └── get-user-by-id.dto.ts    // Request DTO cho Query
│   │   │   └── services/           // Business logic không thuộc CQRS (ví dụ: validation, mapping)
│   │   └── infrastructure/         // 3. INFRASTRUCTURE LAYER
│   │       ├── database/
│   │       │   └── user.repository.ts // Triển khai TypeORM Repository (implements IUserRepository)
│   │       └── external/
│   │           └── notification.service.ts // Gọi External API/Message Queue
│   └── order/
│       └── ...
3. Quy Ước Lớp Ứng Dụng (Application Layer - CQRS)
Lớp này chứa logic nghiệp vụ cốt lõi, được phân tách thành Commands và Queries.

3.1. Commands (Tác vụ Ghi/Write Model)
Mục đích: Chỉ chịu trách nhiệm thay đổi trạng thái của hệ thống (INSERT, UPDATE, DELETE).

Quy tắc Đặt tên: Phải là Động từ + Danh từ và kết thúc bằng Command (ví dụ: CreateUserCommand, DeactivateAccountCommand).

Handlers:

Phải được đặt trong thư mục commands/impl/.

Sử dụng Decorator @CommandHandler của NestJS/CQRS.

Nên gói gọn các thao tác thay đổi dữ liệu trong Transaction để đảm bảo tính nguyên tử.

Không được trả về Domain Entity, chỉ nên trả về một ID, Status, hoặc void/true.

3.2. Queries (Tác vụ Đọc/Read Model)
Mục đích: Chỉ chịu trách nhiệm truy xuất dữ liệu. Không bao giờ được phép thay đổi trạng thái dữ liệu.

Quy tắc Đặt tên: Thường là Get...Query hoặc List...Query (ví dụ: GetUserByIdQuery, ListAllOrdersQuery).

Handlers:

Phải được đặt trong thư mục queries/impl/.

Sử dụng Decorator @QueryHandler của NestJS/CQRS.

Có thể truy vấn trực tiếp cơ sở dữ liệu (ví dụ: dùng QueryBuilder của TypeORM) để tối ưu hóa việc đọc.

Trả về DTOs (Data Transfer Objects) thay vì Domain Entities để kiểm soát dữ liệu trả về cho lớp Interface Adapters.

3.3. DTOs và Validations
Request DTOs: Sử dụng các lớp DTO riêng biệt (trong thư mục dto/ hoặc cùng thư mục với Command/Query) cho việc nhận dữ liệu từ Controller.

Validation: Luôn sử dụng class-validator và ValidationPipe toàn cục của NestJS để xác thực dữ liệu đầu vào.

4. Quy Ước Dữ Liệu và Cơ sở Hạ tầng (TypeORM & Infrastructure)
4.1. Repositories
Abstraction (Interface): Mỗi Repository phải được định nghĩa bằng một Interface hoặc Abstract Class (ví dụ: IUserRepository). Interface này được đặt trong lớp Application hoặc Domain.

Implementation: Lớp triển khai TypeORM Repository (ví dụ: UserRepository) phải nằm trong thư mục infrastructure/database và implements Interface đã định nghĩa.

DI Token: Sử dụng Interface làm DI Token để các Command/Query Handler chỉ phụ thuộc vào Abstraction, không phụ thuộc vào TypeORM cụ thể.

4.2. Domain Entities
Các lớp TypeORM Entity (@Entity() classes) được đặt trong thư mục domain/.

Chúng nên chứa các hành vi nghiệp vụ (business methods) của chính nó, không chỉ là các trường dữ liệu.

4.3. Quản lý Giao dịch (Transactions)
Giao dịch phải được quản lý tại lớp Command Handler.

Sử dụng Connection.transaction() của TypeORM hoặc các thư viện AOP (Aspect-Oriented Programming) để quản lý giao dịch một cách tường minh và an toàn.

5. Quy Ước Lập trình TypeScript & NestJS
5.1. TypeScript
Strict Typing: Luôn bật chế độ strict: true trong tsconfig.json.

Interfaces: Ưu tiên sử dụng TypeScript Interfaces cho việc định nghĩa hợp đồng của Service, Repository, và DTOs.

Readonly: Sử dụng từ khóa readonly cho các thuộc tính không được thay đổi sau khi khởi tạo.

5.2. NestJS Conventions
Decorators: Sử dụng Decorators (@Injectable(), @Module(), v.v.) một cách chính xác theo quy ước của NestJS.

Providers: Sử dụng useClass, useFactory, hoặc useValue trong file *.module.ts để cấu hình Dependency Injection, đặc biệt là khi inject Repository Interface.

Pipes, Guards, Interceptors: Tận dụng tối đa các thành phần này để xử lý các vấn đề xuyên suốt (cross-cutting concerns) như Validation, Authentication, Authorization, và Response Transformation.

6. Xử Lý Lỗi và Khả năng Quan sát (Error Handling & Observability)
6.1. Xử Lý Lỗi Có Cấu Trúc (Standardized Error Handling)
Custom Base Exception (AppError):

Định nghĩa một lớp cơ sở AppError mở rộng từ HttpException của NestJS.

Lớp này phải chứa các thuộc tính để phân loại lỗi: code (Mã lỗi nghiệp vụ/hệ thống) và message (Thông điệp lỗi).

Mã Lỗi Tiêu Chuẩn: Sử dụng phân loại mã lỗi thống nhất:
| Mã Tiền tố | Ý nghĩa | Mô tả |
| :--- | :--- | :--- |
| SYS | System | Lỗi hệ thống/cơ sở hạ tầng (ví dụ: mất kết nối DB) |
| VAL | Validation | Lỗi xác thực dữ liệu đầu vào |
| BIZ | Business | Lỗi logic nghiệp vụ (ví dụ: không tìm thấy người dùng) |
| AUTH | Authentication/Authorization | Lỗi liên quan đến quyền truy cập |

Exception Filter: Triển khai Global Exception Filter để bắt AppError và chuẩn hóa phản hồi API (trả về JSON thống nhất) cho tất cả lỗi.

6.2. Observability (Tracing, Logging, Metrics)
Distributed Tracing (Truy vết Phân tán):

Sử dụng OpenTelemetry hoặc thư viện tương đương để triển khai Tracing.

Đảm bảo mỗi request được gán một Trace ID duy nhất. Trace ID phải được truyền qua HTTP Headers (traceparent) và được ghi lại trong Logs.

Structured Logging:

Sử dụng logger có cấu trúc (ví dụ: Pino hoặc Winston) tích hợp với NestJS.

Logs phải là định dạng JSON để dễ dàng phân tích và truy vấn.

Ghi lại thông tin cần thiết: Trace ID, Span ID, Level, Timestamp, Message, Context (user ID, request path).

Metrics: Sử dụng Prometheus hoặc OpenTelemetry Metrics để thu thập các số liệu chính (độ trễ, tỷ lệ lỗi, thông lượng) từ Controller, Command/Query Handler, và External Call.

## 7. API Design & Kong Gateway Integration

### 7.1. RESTful API Standards
- Sử dụng **HTTP methods** đúng cách: GET (read), POST (create), PUT (update), PATCH (partial update), DELETE (remove)
- Theo **resource-based URLs** với API Gateway prefix: `/KONGAPI/api/v1/users/{id}` thay vì `/api/v1/getUser`
- Sử dụng **plural nouns** cho collections: `/users`, `/orders`, `/products`
- Implement **proper HTTP status codes**: 200, 201, 400, 401, 403, 404, 409, 422, 500
- Sử dụng **consistent response format** với envelope pattern và status code:
  ```json
  {
    "success": true,
    "status_code": 200,
    "data": {...},
    "meta": {
      "pagination": {...},
      "timestamp": "2024-01-15T10:30:00Z",
      "request_id": "req_123456789",
      "trace_id": "trace_987654321"
    }
  }
  ```

### 7.2. Kong Gateway Integration
- Sử dụng **KONGAPI prefix** cho tất cả public endpoints: `/KONGAPI/api/v1/...`
- Implement **Kong-specific headers** và **request routing**
- Áp dụng **Kong middleware** cho authentication, rate limiting, và logging
- Sử dụng **Kong plugins** cho CORS, compression, và monitoring
- Implement **Kong health checks** và **service discovery**

#### Kong API URL Structure:
```
# Public API Endpoints (through Kong Gateway)
/KONGAPI/api/v1/users                    # GET, POST
/KONGAPI/api/v1/users/{id}               # GET, PUT, PATCH, DELETE
/KONGAPI/api/v1/orders                   # GET, POST
/KONGAPI/api/v1/orders/{id}              # GET, PUT, PATCH, DELETE
/KONGAPI/api/v1/products                 # GET, POST
/KONGAPI/api/v1/products/{id}            # GET, PUT, PATCH, DELETE

# Internal API Endpoints (direct access)
/api/v1/health                          # Health check
/api/v1/metrics                         # Prometheus metrics
/api/v1/ready                           # Readiness probe
```

### 7.3. NestJS Controller Configuration
```typescript
// Controller setup with Kong prefix
@Controller('KONGAPI/api/v1')
export class UserController {
  constructor(
    private readonly commandBus: CommandBus,
    private readonly queryBus: QueryBus,
  ) {}

  @Get('users')
  async getUsers(@Query() query: GetUsersDto) {
    return this.queryBus.execute(new GetUsersQuery(query));
  }

  @Post('users')
  async createUser(@Body() createUserDto: CreateUserDto) {
    return this.commandBus.execute(new CreateUserCommand(createUserDto));
  }

  @Get('users/:id')
  async getUser(@Param('id') id: string) {
    return this.queryBus.execute(new GetUserByIdQuery(id));
  }

  @Put('users/:id')
  async updateUser(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {
    return this.commandBus.execute(new UpdateUserCommand(id, updateUserDto));
  }

  @Delete('users/:id')
  async deleteUser(@Param('id') id: string) {
    return this.commandBus.execute(new DeleteUserCommand(id));
  }
}
```

## 8. Response Structure Standards

### 8.1. TypeScript Interface Definitions
```typescript
// Base Response Structure
export interface BaseResponse<T = any> {
  success: boolean;
  status_code: number;
  data?: T;
  meta?: Meta;
  error?: AppError;
}

// Meta Information
export interface Meta {
  pagination?: Pagination;
  timestamp: string;
  request_id?: string;
  trace_id?: string;
}

// Pagination Information
export interface Pagination {
  limit: number;
  offset: number;
  total: number;
  has_next: boolean;
  has_prev: boolean;
}

// Success Response Constructor
export class ResponseBuilder {
  static success<T>(data: T, statusCode: number = 200): BaseResponse<T> {
    return {
      success: true,
      status_code: statusCode,
      data,
      meta: {
        timestamp: new Date().toISOString(),
      },
    };
  }

  static error(error: AppError, statusCode: number): BaseResponse {
    return {
      success: false,
      status_code: statusCode,
      error,
      meta: {
        timestamp: new Date().toISOString(),
      },
    };
  }
}
```

### 8.2. HTTP Status Code Mapping
```typescript
// Success Status Codes
export const HTTP_STATUS = {
  OK: 200,                    // GET, PUT, PATCH success
  CREATED: 201,              // POST success
  ACCEPTED: 202,             // Async operation accepted
  NO_CONTENT: 204,           // DELETE success
  PARTIAL_CONTENT: 206,      // Partial GET success
} as const;

// Client Error Status Codes
export const HTTP_CLIENT_ERROR = {
  BAD_REQUEST: 400,          // Validation errors, malformed request
  UNAUTHORIZED: 401,         // Authentication required
  FORBIDDEN: 403,            // Insufficient permissions
  NOT_FOUND: 404,            // Resource not found
  METHOD_NOT_ALLOWED: 405,   // HTTP method not allowed
  CONFLICT: 409,             // Business rule conflict
  UNPROCESSABLE_ENTITY: 422, // Validation failed
  TOO_MANY_REQUESTS: 429,    // Rate limit exceeded
} as const;

// Server Error Status Codes
export const HTTP_SERVER_ERROR = {
  INTERNAL_SERVER_ERROR: 500, // Internal system error
  NOT_IMPLEMENTED: 501,       // Feature not implemented
  BAD_GATEWAY: 502,           // External service error
  SERVICE_UNAVAILABLE: 503,   // Service temporarily unavailable
  GATEWAY_TIMEOUT: 504,       // External service timeout
} as const;
```

### 8.3. Error Code to Status Code Mapping
```typescript
// Error Code to HTTP Status Code Mapping
export const ERROR_CODE_TO_STATUS_MAP: Record<string, number> = {
  // 1xxx - System Errors -> 500
  'SYS_001': 500, // Internal system error
  'SYS_002': 504, // Request timeout
  'SYS_003': 503, // Service unavailable
  
  // 2xxx - Validation Errors -> 400/422
  'VAL_001': 400, // Required field missing
  'VAL_002': 422, // Invalid format
  'VAL_003': 422, // Value out of range
  
  // 3xxx - Authentication/Authorization -> 401/403
  'AUTH_001': 401, // Invalid token
  'AUTH_002': 401, // Token expired
  'AUTH_003': 403, // Insufficient permissions
  
  // 4xxx - Business Logic -> 404/409/422
  'BIZ_001': 404, // Resource not found
  'BIZ_002': 409, // Business rule conflict
  'BIZ_003': 422, // Business limit exceeded
  
  // 5xxx - External Dependencies -> 502/503/504
  'EXT_001': 504, // External service timeout
  'EXT_002': 503, // External service unavailable
  'EXT_003': 502, // External service error
};

// Get HTTP Status Code from Error Code
export function getStatusFromErrorCode(errorCode: string): number {
  return ERROR_CODE_TO_STATUS_MAP[errorCode] || 500;
}
```

## 9. Authentication & Security

### 9.1. Kong Gateway Authentication Strategy

#### Kong Gateway Level Authentication:
- **Kong JWT Plugin** xử lý token validation ở gateway level
- **No JWT plugin** = Không cần authentication (public endpoints)
- **JWT plugin configured** = Authentication required (protected endpoints)
- **Kong validates JWT** trước khi forward requests đến NestJS application

#### NestJS Application Level:
- **Trust Kong's authentication** - Kong đã validate token
- **Extract user info** từ Kong headers (X-Consumer-ID, X-Consumer-Username, etc.)
- **Không cần re-validate JWT** trong NestJS application
- **Focus on authorization** (role-based access control)

### 9.2. Kong Middleware Integration
```typescript
// Kong Consumer Middleware - extracts consumer info from Kong headers
@Injectable()
export class KongConsumerMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    // Extract Kong headers (set by Kong JWT plugin)
    const kongRequestID = req.headers['x-kong-request-id'] as string;
    const kongConsumerID = req.headers['x-consumer-id'] as string;
    const kongConsumerUsername = req.headers['x-consumer-username'] as string;
    const kongConsumerCustomID = req.headers['x-consumer-custom-id'] as string;
    
    // Add to request context
    req['kong_request_id'] = kongRequestID;
    req['kong_consumer_id'] = kongConsumerID;
    req['kong_consumer_username'] = kongConsumerUsername;
    req['kong_consumer_custom_id'] = kongConsumerCustomID;
    
    // Log Kong-specific information
    console.log('Kong authenticated request', {
      kong_request_id: kongRequestID,
      kong_consumer_id: kongConsumerID,
      kong_consumer_username: kongConsumerUsername,
      path: req.url,
      method: req.method,
    });
    
    next();
  }
}

// Kong Public Middleware (for Public Endpoints)
@Injectable()
export class KongPublicMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    // Extract Kong headers (may or may not be present for public endpoints)
    const kongRequestID = req.headers['x-kong-request-id'] as string;
    
    // Add to request context
    req['kong_request_id'] = kongRequestID;
    
    // Log public request
    console.log('Kong public request', {
      kong_request_id: kongRequestID,
      path: req.url,
      method: req.method,
    });
    
    next();
  }
}
```

### 9.3. Authentication Requirements by Endpoint Type

#### Public Endpoints (No Kong JWT Plugin - No Authentication Required):
```typescript
// Public endpoints - NO JWT plugin in Kong configuration
@Controller('KONGAPI/api/v1/public')
export class PublicController {
  // Health and monitoring
  @Get('health')
  async healthCheck() {
    return ResponseBuilder.success({ status: 'healthy' });
  }

  @Get('ready')
  async readinessCheck() {
    return ResponseBuilder.success({ status: 'ready' });
  }

  // Authentication endpoints
  @Post('auth/login')
  async login(@Body() loginDto: LoginDto) {
    return this.commandBus.execute(new LoginCommand(loginDto));
  }

  @Post('auth/register')
  async register(@Body() registerDto: RegisterDto) {
    return this.commandBus.execute(new RegisterCommand(registerDto));
  }
}
```

#### Protected Endpoints (Kong JWT Plugin Required):
```typescript
// Protected endpoints - Kong JWT plugin validates token before reaching NestJS app
@Controller('KONGAPI/api/v1')
@UseGuards(KongConsumerGuard) // Extract consumer info from Kong headers
export class UserController {
  constructor(
    private readonly commandBus: CommandBus,
    private readonly queryBus: QueryBus,
  ) {}

  @Get('users')
  async getUsers(@Query() query: GetUsersDto) {
    return this.queryBus.execute(new GetUsersQuery(query));
  }

  @Post('users')
  async createUser(@Body() createUserDto: CreateUserDto) {
    return this.commandBus.execute(new CreateUserCommand(createUserDto));
  }
}
```

### 9.4. Role-based Authorization
```typescript
// Role-based Authorization Guard
@Injectable()
export class RoleGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<string[]>('roles', [
      context.getHandler(),
      context.getClass(),
    ]);

    if (!requiredRoles) {
      return true;
    }

    const request = context.switchToHttp().getRequest();
    const userRole = request['user_role'] || request.headers['x-user-role'];

    return requiredRoles.some((role) => userRole === role);
  }
}

// Usage in Controller
@Controller('KONGAPI/api/v1/admin')
@UseGuards(KongConsumerGuard, RoleGuard)
@Roles('admin')
export class AdminController {
  @Get('users')
  async getAllUsers() {
    return this.queryBus.execute(new GetAllUsersQuery());
  }
}
```

## 10. Database Best Practices với TypeORM

### 10.1. Database Naming Conventions

#### Table Naming Standards:
- **Tất cả tables** phải bắt đầu với prefix `BMM_`
- Sử dụng **UPPERCASE** cho tất cả table names
- Sử dụng **UNDERSCORE** để phân tách từ
- Sử dụng **SINGULAR** table names
- Ví dụ: `BMM_USERS`, `BMM_ORDERS`, `BMM_PRODUCTS`

#### Column Naming Standards:
- **Tất cả columns** phải sử dụng **UPPERCASE**
- Sử dụng **UNDERSCORE** để phân tách từ
- Sử dụng **descriptive** column names
- Ví dụ: `USER_ID`, `CREATED_AT`, `UPDATED_AT`, `FIRST_NAME`, `LAST_NAME`

#### Index Naming Standards:
- **Primary Key**: `PK_BMM_TABLENAME` (ví dụ: `PK_BMM_USERS`)
- **Unique Index**: `UK_BMM_TABLENAME_COLUMN` (ví dụ: `UK_BMM_USERS_USERNAME`)
- **Foreign Key**: `FK_BMM_TABLENAME_REFERENCEDTABLE` (ví dụ: `FK_BMM_ORDERS_BMM_USERS`)
- **Regular Index**: `IDX_BMM_TABLENAME_COLUMN` (ví dụ: `IDX_BMM_USERS_EMAIL`)

### 10.2. Entity Design Standards
```typescript
// Base Entity với common fields
@Entity('BMM_BASE_ENTITY')
export abstract class BaseEntity {
  @PrimaryGeneratedColumn('uuid')
  @Column({ name: 'ID', type: 'uuid' })
  id: string;

  @CreateDateColumn({ name: 'CREATED_AT' })
  createdAt: Date;

  @UpdateDateColumn({ name: 'UPDATED_AT' })
  updatedAt: Date;

  @DeleteDateColumn({ name: 'DELETED_AT', nullable: true })
  deletedAt?: Date;

  @Column({ name: 'CREATED_BY', nullable: true })
  createdBy?: string;

  @Column({ name: 'UPDATED_BY', nullable: true })
  updatedBy?: string;

  @VersionColumn({ name: 'VERSION' })
  version: number;
}

// User Entity example
@Entity('BMM_USERS')
export class User extends BaseEntity {
  @Column({ name: 'USERNAME', unique: true })
  username: string;

  @Column({ name: 'EMAIL', unique: true })
  email: string;

  @Column({ name: 'PASSWORD_HASH' })
  passwordHash: string;

  @Column({ name: 'FIRST_NAME' })
  firstName: string;

  @Column({ name: 'LAST_NAME' })
  lastName: string;

  @Column({ name: 'IS_ACTIVE', default: true })
  isActive: boolean;

  @Column({ name: 'PHONE_NUMBER', nullable: true })
  phoneNumber?: string;

  @Column({ name: 'DATE_OF_BIRTH', type: 'date', nullable: true })
  dateOfBirth?: Date;

  @Column({ name: 'ADDRESS', type: 'text', nullable: true })
  address?: string;

  // Business methods
  getFullName(): string {
    return `${this.firstName} ${this.lastName}`;
  }

  isAccountActive(): boolean {
    return this.isActive && !this.deletedAt;
  }
}

// Order Entity example với relationships
@Entity('BMM_ORDERS')
export class Order extends BaseEntity {
  @Column({ name: 'ORDER_NUMBER', unique: true })
  orderNumber: string;

  @Column({ name: 'USER_ID', type: 'uuid' })
  userId: string;

  @Column({ name: 'TOTAL_AMOUNT', type: 'decimal', precision: 10, scale: 2 })
  totalAmount: number;

  @Column({ name: 'STATUS', default: 'PENDING' })
  status: string;

  @Column({ name: 'ORDER_DATE', type: 'timestamp' })
  orderDate: Date;

  @Column({ name: 'SHIPPING_ADDRESS', type: 'text' })
  shippingAddress: string;

  @Column({ name: 'NOTES', type: 'text', nullable: true })
  notes?: string;

  // Relationships
  @ManyToOne(() => User, user => user.orders)
  @JoinColumn({ name: 'USER_ID' })
  user: User;

  @OneToMany(() => OrderItem, orderItem => orderItem.order)
  orderItems: OrderItem[];

  // Business methods
  calculateTotal(): number {
    return this.orderItems?.reduce((total, item) => total + item.subtotal, 0) || 0;
  }

  isCompleted(): boolean {
    return this.status === 'COMPLETED';
  }
}

// OrderItem Entity example
@Entity('BMM_ORDER_ITEMS')
export class OrderItem extends BaseEntity {
  @Column({ name: 'ORDER_ID', type: 'uuid' })
  orderId: string;

  @Column({ name: 'PRODUCT_ID', type: 'uuid' })
  productId: string;

  @Column({ name: 'QUANTITY', type: 'int' })
  quantity: number;

  @Column({ name: 'UNIT_PRICE', type: 'decimal', precision: 10, scale: 2 })
  unitPrice: number;

  @Column({ name: 'SUBTOTAL', type: 'decimal', precision: 10, scale: 2 })
  subtotal: number;

  // Relationships
  @ManyToOne(() => Order, order => order.orderItems)
  @JoinColumn({ name: 'ORDER_ID' })
  order: Order;

  @ManyToOne(() => Product)
  @JoinColumn({ name: 'PRODUCT_ID' })
  product: Product;

  // Business methods
  calculateSubtotal(): number {
    return this.quantity * this.unitPrice;
  }
}

// Product Entity example
@Entity('BMM_PRODUCTS')
export class Product extends BaseEntity {
  @Column({ name: 'PRODUCT_CODE', unique: true })
  productCode: string;

  @Column({ name: 'PRODUCT_NAME' })
  productName: string;

  @Column({ name: 'DESCRIPTION', type: 'text', nullable: true })
  description?: string;

  @Column({ name: 'PRICE', type: 'decimal', precision: 10, scale: 2 })
  price: number;

  @Column({ name: 'STOCK_QUANTITY', type: 'int', default: 0 })
  stockQuantity: number;

  @Column({ name: 'CATEGORY_ID', type: 'uuid', nullable: true })
  categoryId?: string;

  @Column({ name: 'IS_ACTIVE', default: true })
  isActive: boolean;

  // Relationships
  @ManyToOne(() => Category)
  @JoinColumn({ name: 'CATEGORY_ID' })
  category?: Category;

  // Business methods
  isInStock(): boolean {
    return this.stockQuantity > 0;
  }

  isAvailable(): boolean {
    return this.isActive && this.isInStock();
  }
}

// Category Entity example
@Entity('BMM_CATEGORIES')
export class Category extends BaseEntity {
  @Column({ name: 'CATEGORY_NAME' })
  categoryName: string;

  @Column({ name: 'DESCRIPTION', type: 'text', nullable: true })
  description?: string;

  @Column({ name: 'PARENT_CATEGORY_ID', type: 'uuid', nullable: true })
  parentCategoryId?: string;

  @Column({ name: 'IS_ACTIVE', default: true })
  isActive: boolean;

  // Relationships
  @ManyToOne(() => Category, category => category.subCategories)
  @JoinColumn({ name: 'PARENT_CATEGORY_ID' })
  parentCategory?: Category;

  @OneToMany(() => Category, category => category.parentCategory)
  subCategories: Category[];

  @OneToMany(() => Product, product => product.category)
  products: Product[];
}
```

### 10.2. Repository Pattern với TypeORM
```typescript
// Repository Interface (Domain Layer)
export interface IUserRepository {
  findById(id: string): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
  findByUsername(username: string): Promise<User | null>;
  save(user: User): Promise<User>;
  delete(id: string): Promise<void>;
  findActiveUsers(limit: number, offset: number): Promise<[User[], number]>;
}

// Repository Implementation (Infrastructure Layer)
@Injectable()
export class UserRepository implements IUserRepository {
  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
  ) {}

  async findById(id: string): Promise<User | null> {
    return this.userRepository.findOne({
      where: { id, deletedAt: IsNull() },
    });
  }

  async findByEmail(email: string): Promise<User | null> {
    return this.userRepository.findOne({
      where: { email, deletedAt: IsNull() },
    });
  }

  async findByUsername(username: string): Promise<User | null> {
    return this.userRepository.findOne({
      where: { username, deletedAt: IsNull() },
    });
  }

  async save(user: User): Promise<User> {
    return this.userRepository.save(user);
  }

  async delete(id: string): Promise<void> {
    await this.userRepository.softDelete(id);
  }

  async findActiveUsers(limit: number, offset: number): Promise<[User[], number]> {
    return this.userRepository.findAndCount({
      where: { isActive: true, deletedAt: IsNull() },
      take: limit,
      skip: offset,
      order: { createdAt: 'DESC' },
    });
  }
}
```

### 10.3. Transaction Management
```typescript
// Command Handler với Transaction
@CommandHandler(CreateUserCommand)
export class CreateUserHandler implements ICommandHandler<CreateUserCommand> {
  constructor(
    @Inject('IUserRepository')
    private readonly userRepository: IUserRepository,
    @Inject('INotificationService')
    private readonly notificationService: INotificationService,
    private readonly dataSource: DataSource,
  ) {}

  async execute(command: CreateUserCommand): Promise<User> {
    return this.dataSource.transaction(async (manager) => {
      // Create user
      const user = new User();
      user.username = command.username;
      user.email = command.email;
      user.passwordHash = await this.hashPassword(command.password);
      user.firstName = command.firstName;
      user.lastName = command.lastName;

      const savedUser = await manager.save(User, user);

      // Send welcome notification (async)
      this.notificationService.sendWelcomeEmail(savedUser.email).catch((error) => {
        console.error('Failed to send welcome email:', error);
      });

      return savedUser;
    });
  }

  private async hashPassword(password: string): Promise<string> {
    // Implementation for password hashing
    return password; // Simplified for example
  }
}
```

### 10.4. Query Optimization với TypeORM
```typescript
// Query Handler với optimized queries
@QueryHandler(GetUsersQuery)
export class GetUsersHandler implements IQueryHandler<GetUsersQuery> {
  constructor(
    @Inject('IUserRepository')
    private readonly userRepository: IUserRepository,
  ) {}

  async execute(query: GetUsersQuery): Promise<GetUsersResult> {
    const { limit = 10, offset = 0, search, status } = query;

    const queryBuilder = this.userRepository
      .createQueryBuilder('user')
      .where('user.deletedAt IS NULL')
      .orderBy('user.createdAt', 'DESC')
      .limit(limit)
      .offset(offset);

    // Add search condition
    if (search) {
      queryBuilder.andWhere(
        '(user.firstName ILIKE :search OR user.lastName ILIKE :search OR user.email ILIKE :search)',
        { search: `%${search}%` }
      );
    }

    // Add status filter
    if (status !== undefined) {
      queryBuilder.andWhere('user.isActive = :status', { status });
    }

    const [users, total] = await queryBuilder.getManyAndCount();

    return {
      users: users.map(user => ({
        id: user.id,
        username: user.username,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        fullName: user.getFullName(),
        isActive: user.isActive,
        createdAt: user.createdAt,
      })),
      total,
      limit,
      offset,
    };
  }
}
```

### 10.5. Database Migration Examples
```sql
-- Migration: 001_create_bmm_users_table.sql
CREATE TABLE BMM_USERS (
    ID UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    USERNAME VARCHAR(50) NOT NULL UNIQUE,
    EMAIL VARCHAR(100) NOT NULL UNIQUE,
    PASSWORD_HASH VARCHAR(255) NOT NULL,
    FIRST_NAME VARCHAR(50) NOT NULL,
    LAST_NAME VARCHAR(50) NOT NULL,
    PHONE_NUMBER VARCHAR(20),
    DATE_OF_BIRTH DATE,
    ADDRESS TEXT,
    IS_ACTIVE BOOLEAN DEFAULT TRUE,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    DELETED_AT TIMESTAMP NULL,
    CREATED_BY VARCHAR(50),
    UPDATED_BY VARCHAR(50),
    VERSION INTEGER DEFAULT 1
);

-- Indexes for BMM_USERS
CREATE INDEX IDX_BMM_USERS_EMAIL ON BMM_USERS(EMAIL);
CREATE INDEX IDX_BMM_USERS_USERNAME ON BMM_USERS(USERNAME);
CREATE INDEX IDX_BMM_USERS_IS_ACTIVE ON BMM_USERS(IS_ACTIVE);
CREATE INDEX IDX_BMM_USERS_CREATED_AT ON BMM_USERS(CREATED_AT);

-- Migration: 002_create_bmm_categories_table.sql
CREATE TABLE BMM_CATEGORIES (
    ID UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    CATEGORY_NAME VARCHAR(100) NOT NULL,
    DESCRIPTION TEXT,
    PARENT_CATEGORY_ID UUID,
    IS_ACTIVE BOOLEAN DEFAULT TRUE,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    DELETED_AT TIMESTAMP NULL,
    CREATED_BY VARCHAR(50),
    UPDATED_BY VARCHAR(50),
    VERSION INTEGER DEFAULT 1,
    
    CONSTRAINT FK_BMM_CATEGORIES_BMM_CATEGORIES 
        FOREIGN KEY (PARENT_CATEGORY_ID) 
        REFERENCES BMM_CATEGORIES(ID)
);

-- Indexes for BMM_CATEGORIES
CREATE INDEX IDX_BMM_CATEGORIES_CATEGORY_NAME ON BMM_CATEGORIES(CATEGORY_NAME);
CREATE INDEX IDX_BMM_CATEGORIES_PARENT_CATEGORY_ID ON BMM_CATEGORIES(PARENT_CATEGORY_ID);
CREATE INDEX IDX_BMM_CATEGORIES_IS_ACTIVE ON BMM_CATEGORIES(IS_ACTIVE);

-- Migration: 003_create_bmm_products_table.sql
CREATE TABLE BMM_PRODUCTS (
    ID UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    PRODUCT_CODE VARCHAR(50) NOT NULL UNIQUE,
    PRODUCT_NAME VARCHAR(200) NOT NULL,
    DESCRIPTION TEXT,
    PRICE DECIMAL(10,2) NOT NULL,
    STOCK_QUANTITY INTEGER DEFAULT 0,
    CATEGORY_ID UUID,
    IS_ACTIVE BOOLEAN DEFAULT TRUE,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    DELETED_AT TIMESTAMP NULL,
    CREATED_BY VARCHAR(50),
    UPDATED_BY VARCHAR(50),
    VERSION INTEGER DEFAULT 1,
    
    CONSTRAINT FK_BMM_PRODUCTS_BMM_CATEGORIES 
        FOREIGN KEY (CATEGORY_ID) 
        REFERENCES BMM_CATEGORIES(ID)
);

-- Indexes for BMM_PRODUCTS
CREATE INDEX IDX_BMM_PRODUCTS_PRODUCT_CODE ON BMM_PRODUCTS(PRODUCT_CODE);
CREATE INDEX IDX_BMM_PRODUCTS_PRODUCT_NAME ON BMM_PRODUCTS(PRODUCT_NAME);
CREATE INDEX IDX_BMM_PRODUCTS_CATEGORY_ID ON BMM_PRODUCTS(CATEGORY_ID);
CREATE INDEX IDX_BMM_PRODUCTS_IS_ACTIVE ON BMM_PRODUCTS(IS_ACTIVE);
CREATE INDEX IDX_BMM_PRODUCTS_STOCK_QUANTITY ON BMM_PRODUCTS(STOCK_QUANTITY);

-- Migration: 004_create_bmm_orders_table.sql
CREATE TABLE BMM_ORDERS (
    ID UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ORDER_NUMBER VARCHAR(50) NOT NULL UNIQUE,
    USER_ID UUID NOT NULL,
    TOTAL_AMOUNT DECIMAL(10,2) NOT NULL,
    STATUS VARCHAR(20) DEFAULT 'PENDING',
    ORDER_DATE TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    SHIPPING_ADDRESS TEXT NOT NULL,
    NOTES TEXT,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    DELETED_AT TIMESTAMP NULL,
    CREATED_BY VARCHAR(50),
    UPDATED_BY VARCHAR(50),
    VERSION INTEGER DEFAULT 1,
    
    CONSTRAINT FK_BMM_ORDERS_BMM_USERS 
        FOREIGN KEY (USER_ID) 
        REFERENCES BMM_USERS(ID)
);

-- Indexes for BMM_ORDERS
CREATE INDEX IDX_BMM_ORDERS_ORDER_NUMBER ON BMM_ORDERS(ORDER_NUMBER);
CREATE INDEX IDX_BMM_ORDERS_USER_ID ON BMM_ORDERS(USER_ID);
CREATE INDEX IDX_BMM_ORDERS_STATUS ON BMM_ORDERS(STATUS);
CREATE INDEX IDX_BMM_ORDERS_ORDER_DATE ON BMM_ORDERS(ORDER_DATE);

-- Migration: 005_create_bmm_order_items_table.sql
CREATE TABLE BMM_ORDER_ITEMS (
    ID UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ORDER_ID UUID NOT NULL,
    PRODUCT_ID UUID NOT NULL,
    QUANTITY INTEGER NOT NULL,
    UNIT_PRICE DECIMAL(10,2) NOT NULL,
    SUBTOTAL DECIMAL(10,2) NOT NULL,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    DELETED_AT TIMESTAMP NULL,
    CREATED_BY VARCHAR(50),
    UPDATED_BY VARCHAR(50),
    VERSION INTEGER DEFAULT 1,
    
    CONSTRAINT FK_BMM_ORDER_ITEMS_BMM_ORDERS 
        FOREIGN KEY (ORDER_ID) 
        REFERENCES BMM_ORDERS(ID),
    CONSTRAINT FK_BMM_ORDER_ITEMS_BMM_PRODUCTS 
        FOREIGN KEY (PRODUCT_ID) 
        REFERENCES BMM_PRODUCTS(ID)
);

-- Indexes for BMM_ORDER_ITEMS
CREATE INDEX IDX_BMM_ORDER_ITEMS_ORDER_ID ON BMM_ORDER_ITEMS(ORDER_ID);
CREATE INDEX IDX_BMM_ORDER_ITEMS_PRODUCT_ID ON BMM_ORDER_ITEMS(PRODUCT_ID);
```

### 10.6. TypeORM Configuration với BMM_ Naming
```typescript
// TypeORM Configuration
export const typeOrmConfig: TypeOrmModuleOptions = {
  type: 'postgres',
  host: process.env.DATABASE_HOST || 'localhost',
  port: parseInt(process.env.DATABASE_PORT) || 5432,
  username: process.env.DATABASE_USER || 'postgres',
  password: process.env.DATABASE_PASSWORD || 'password',
  database: process.env.DATABASE_NAME || 'bmm_db',
  entities: [User, Order, OrderItem, Product, Category],
  synchronize: process.env.NODE_ENV === 'development',
  logging: process.env.NODE_ENV === 'development',
  namingStrategy: new SnakeNamingStrategy(), // Converts camelCase to snake_case
  migrations: ['dist/migrations/*.js'],
  migrationsRun: true,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
};

// Custom Naming Strategy để handle BMM_ prefix
export class BMMNamingStrategy extends SnakeNamingStrategy {
  tableName(className: string, customName?: string): string {
    if (customName) {
      return customName;
    }
    // Convert ClassName to BMM_TABLE_NAME format
    const snakeCase = className.replace(/([A-Z])/g, '_$1').toLowerCase();
    return `BMM_${snakeCase.substring(1).toUpperCase()}`;
  }

  columnName(propertyName: string, customName?: string, embeddedPrefixes: string[] = []): string {
    if (customName) {
      return customName;
    }
    // Convert propertyName to COLUMN_NAME format
    const snakeCase = propertyName.replace(/([A-Z])/g, '_$1').toLowerCase();
    return snakeCase.substring(1).toUpperCase();
  }

  indexName(tableOrName: string, columns: string[], where?: string): string {
    const tableName = typeof tableOrName === 'string' ? tableOrName : tableOrName.name;
    const columnNames = columns.join('_');
    return `IDX_${tableName}_${columnNames}`;
  }

  primaryKeyName(tableOrName: string, columnNames: string[]): string {
    const tableName = typeof tableOrName === 'string' ? tableOrName : tableOrName.name;
    return `PK_${tableName}`;
  }

  uniqueConstraintName(tableOrName: string, columnNames: string[]): string {
    const tableName = typeof tableOrName === 'string' ? tableOrName : tableOrName.name;
    const columnNamesStr = columnNames.join('_');
    return `UK_${tableName}_${columnNamesStr}`;
  }

  foreignKeyName(tableOrName: string, columnNames: string[], referencedTablePath?: string, referencedColumnNames?: string[]): string {
    const tableName = typeof tableOrName === 'string' ? tableOrName : tableOrName.name;
    const referencedTableName = referencedTablePath?.split('.').pop();
    return `FK_${tableName}_${referencedTableName}`;
  }
}
```

## 11. Testing & Quality Assurance

### 11.1. Unit Testing với Jest
```typescript
// Command Handler Test
describe('CreateUserHandler', () => {
  let handler: CreateUserHandler;
  let userRepository: jest.Mocked<IUserRepository>;
  let dataSource: jest.Mocked<DataSource>;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        CreateUserHandler,
        {
          provide: 'IUserRepository',
          useValue: {
            save: jest.fn(),
            findByEmail: jest.fn(),
          },
        },
        {
          provide: DataSource,
          useValue: {
            transaction: jest.fn(),
          },
        },
      ],
    }).compile();

    handler = module.get<CreateUserHandler>(CreateUserHandler);
    userRepository = module.get('IUserRepository');
    dataSource = module.get(DataSource);
  });

  it('should create user successfully', async () => {
    // Arrange
    const command = new CreateUserCommand({
      username: 'testuser',
      email: 'test@example.com',
      password: 'password123',
      firstName: 'Test',
      lastName: 'User',
    });

    const mockUser = new User();
    mockUser.id = 'user-id';
    mockUser.username = command.username;

    userRepository.findByEmail.mockResolvedValue(null);
    dataSource.transaction.mockImplementation(async (callback) => {
      return callback({
        save: jest.fn().mockResolvedValue(mockUser),
      });
    });

    // Act
    const result = await handler.execute(command);

    // Assert
    expect(result).toBeDefined();
    expect(result.username).toBe(command.username);
    expect(userRepository.findByEmail).toHaveBeenCalledWith(command.email);
  });

  it('should throw error if email already exists', async () => {
    // Arrange
    const command = new CreateUserCommand({
      username: 'testuser',
      email: 'existing@example.com',
      password: 'password123',
      firstName: 'Test',
      lastName: 'User',
    });

    const existingUser = new User();
    userRepository.findByEmail.mockResolvedValue(existingUser);

    // Act & Assert
    await expect(handler.execute(command)).rejects.toThrow('Email already exists');
  });
});
```

### 11.2. Integration Testing
```typescript
// Integration Test
describe('UserController (Integration)', () => {
  let app: INestApplication;
  let userRepository: Repository<User>;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [
        AppModule,
        TypeOrmModule.forRoot({
          type: 'postgres',
          host: 'localhost',
          port: 5432,
          username: 'test',
          password: 'test',
          database: 'test_db',
          entities: [User],
          synchronize: true,
        }),
      ],
    }).compile();

    app = moduleFixture.createNestApplication();
    userRepository = moduleFixture.get<Repository<User>>(getRepositoryToken(User));
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  beforeEach(async () => {
    await userRepository.clear();
  });

  it('POST /KONGAPI/api/v1/users should create user', async () => {
    // Arrange
    const createUserDto = {
      username: 'testuser',
      email: 'test@example.com',
      password: 'password123',
      firstName: 'Test',
      lastName: 'User',
    };

    // Act
    const response = await request(app.getHttpServer())
      .post('/KONGAPI/api/v1/users')
      .send(createUserDto)
      .expect(201);

    // Assert
    expect(response.body.success).toBe(true);
    expect(response.body.data.username).toBe(createUserDto.username);

    // Verify in database
    const user = await userRepository.findOne({
      where: { username: createUserDto.username },
    });
    expect(user).toBeDefined();
  });

  it('GET /KONGAPI/api/v1/users should return users list', async () => {
    // Arrange
    const user = new User();
    user.username = 'testuser';
    user.email = 'test@example.com';
    user.passwordHash = 'hashed';
    user.firstName = 'Test';
    user.lastName = 'User';
    await userRepository.save(user);

    // Act
    const response = await request(app.getHttpServer())
      .get('/KONGAPI/api/v1/users')
      .expect(200);

    // Assert
    expect(response.body.success).toBe(true);
    expect(response.body.data.users).toHaveLength(1);
    expect(response.body.data.users[0].username).toBe('testuser');
  });
});
```

### 11.3. E2E Testing
```typescript
// E2E Test
describe('User E2E', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  it('/KONGAPI/api/v1/users (POST)', () => {
    return request(app.getHttpServer())
      .post('/KONGAPI/api/v1/users')
      .send({
        username: 'e2euser',
        email: 'e2e@example.com',
        password: 'password123',
        firstName: 'E2E',
        lastName: 'User',
      })
      .expect(201)
      .expect((res) => {
        expect(res.body.success).toBe(true);
        expect(res.body.data.username).toBe('e2euser');
      });
  });

  it('/KONGAPI/api/v1/users (GET)', () => {
    return request(app.getHttpServer())
      .get('/KONGAPI/api/v1/users')
      .expect(200)
      .expect((res) => {
        expect(res.body.success).toBe(true);
        expect(Array.isArray(res.body.data.users)).toBe(true);
      });
  });
});
```

### 11.4. Code Quality Standards
```typescript
// ESLint Configuration (.eslintrc.js)
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    '@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'error',
    '@typescript-eslint/no-unused-vars': 'error',
    'prefer-const': 'error',
    'no-var': 'error',
  },
};

// Prettier Configuration (.prettierrc)
{
  "singleQuote": true,
  "trailingComma": "all",
  "tabWidth": 2,
  "semi": true,
  "printWidth": 100
}

// Jest Configuration (jest.config.js)
module.exports = {
  moduleFileExtensions: ['js', 'json', 'ts'],
  rootDir: 'src',
  testRegex: '.*\\.spec\\.ts$',
  transform: {
    '^.+\\.(t|j)s$': 'ts-jest',
  },
  collectCoverageFrom: [
    '**/*.(t|j)s',
    '!**/*.spec.ts',
    '!**/*.interface.ts',
    '!**/node_modules/**',
  ],
  coverageDirectory: '../coverage',
  testEnvironment: 'node',
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
};
```

## 12. Deployment & DevOps

### 12.1. Docker Configuration
```dockerfile
# Multi-stage Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./
COPY tsconfig*.json ./

# Install dependencies
RUN npm ci --only=production && npm cache clean --force

# Copy source code
COPY src/ ./src/

# Build application
RUN npm run build

# Production stage
FROM node:18-alpine AS production

WORKDIR /app

# Install dumb-init for proper signal handling
RUN apk add --no-cache dumb-init

# Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nestjs -u 1001

# Copy built application
COPY --from=builder --chown=nestjs:nodejs /app/dist ./dist
COPY --from=builder --chown=nestjs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nestjs:nodejs /app/package*.json ./

# Switch to non-root user
USER nestjs

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/api/v1/health || exit 1

# Start application
ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "dist/main.js"]
```

### 12.2. Docker Compose
```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_HOST=postgres
      - DATABASE_PORT=5432
      - DATABASE_NAME=app_db
      - DATABASE_USER=app_user
      - DATABASE_PASSWORD=app_password
      - REDIS_HOST=redis
      - REDIS_PORT=6379
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/api/v1/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=app_db
      - POSTGRES_USER=app_user
      - POSTGRES_PASSWORD=app_password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./migrations:/docker-entrypoint-initdb.d
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U app_user -d app_db"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - app
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
```

### 12.3. Kubernetes Deployment
```yaml
# k8s-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nestjs-app
  labels:
    app: nestjs-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nestjs-app
  template:
    metadata:
      labels:
        app: nestjs-app
    spec:
      containers:
      - name: nestjs-app
        image: your-registry/nestjs-app:latest
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "production"
        - name: DATABASE_HOST
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: database-host
        - name: DATABASE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: database-password
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /api/v1/health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /api/v1/ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
        securityContext:
          runAsNonRoot: true
          runAsUser: 1001
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL

---
apiVersion: v1
kind: Service
metadata:
  name: nestjs-app-service
spec:
  selector:
    app: nestjs-app
  ports:
  - protocol: TCP
    port: 80
    targetPort: 3000
  type: ClusterIP

---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: nestjs-app-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  tls:
  - hosts:
    - api.yourdomain.com
    secretName: nestjs-app-tls
  rules:
  - host: api.yourdomain.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: nestjs-app-service
            port:
              number: 80
```

### 12.4. CI/CD Pipeline (GitHub Actions)
```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
    - uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run linting
      run: npm run lint

    - name: Run type checking
      run: npm run type-check

    - name: Run unit tests
      run: npm run test:unit
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
        REDIS_URL: redis://localhost:6379

    - name: Run integration tests
      run: npm run test:integration
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
        REDIS_URL: redis://localhost:6379

    - name: Generate coverage report
      run: npm run test:cov

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Build application
      run: npm run build

    - name: Log in to Container Registry
      uses: docker/login-action@v2
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v4
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}

    - name: Deploy to Kubernetes
      uses: azure/k8s-deploy@v1
      with:
        manifests: |
          k8s-deployment.yaml
        images: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
```

### 12.5. Monitoring & Observability
```typescript
// Health Check Controller
@Controller('api/v1')
export class HealthController {
  constructor(
    private readonly health: HealthCheckService,
    private readonly db: TypeOrmHealthIndicator,
    private readonly redis: RedisHealthIndicator,
  ) {}

  @Get('health')
  @HealthCheck()
  check() {
    return this.health.check([
      () => this.db.pingCheck('database'),
      () => this.redis.pingCheck('redis'),
    ]);
  }

  @Get('ready')
  @HealthCheck()
  readiness() {
    return this.health.check([
      () => this.db.pingCheck('database'),
      () => this.redis.pingCheck('redis'),
    ]);
  }

  @Get('live')
  liveness() {
    return { status: 'ok', timestamp: new Date().toISOString() };
  }
}

// Prometheus Metrics
@Injectable()
export class MetricsService {
  private readonly httpRequestDuration = new Histogram({
    name: 'http_request_duration_seconds',
    help: 'Duration of HTTP requests in seconds',
    labelNames: ['method', 'route', 'status_code'],
  });

  private readonly httpRequestTotal = new Counter({
    name: 'http_requests_total',
    help: 'Total number of HTTP requests',
    labelNames: ['method', 'route', 'status_code'],
  });

  recordHttpRequest(method: string, route: string, statusCode: number, duration: number) {
    this.httpRequestTotal.inc({ method, route, status_code: statusCode.toString() });
    this.httpRequestDuration.observe({ method, route, status_code: statusCode.toString() }, duration);
  }
}
```

## 13. Key Conventions Summary

### 13.1. Architecture Principles
1. **Clean Architecture** với tách biệt rõ ràng các layer
2. **CQRS Pattern** để tách biệt Read/Write operations
3. **Dependency Injection** sử dụng NestJS DI container
4. **Repository Pattern** với TypeORM
5. **Domain-Driven Design** với business logic trong entities

### 13.2. Code Quality Standards
1. **TypeScript strict mode** enabled
2. **ESLint + Prettier** cho code formatting
3. **Jest** cho testing với coverage threshold 80%
4. **Docker** cho containerization
5. **Kubernetes** cho orchestration

### 13.3. API Standards
1. **RESTful API** với proper HTTP methods
2. **Kong Gateway** integration với JWT authentication
3. **Consistent response format** với success/error structure
4. **Proper HTTP status codes** mapping
5. **API versioning** với `/KONGAPI/api/v1/` prefix

### 13.4. Security Best Practices
1. **Kong JWT Plugin** cho authentication
2. **Role-based authorization** trong NestJS
3. **Input validation** với class-validator
4. **SQL injection prevention** với TypeORM
5. **HTTPS only** trong production

### 13.5. Performance & Scalability
1. **Database indexing** strategies
2. **Query optimization** với TypeORM QueryBuilder
3. **Caching** với Redis
4. **Connection pooling** cho database
5. **Horizontal scaling** với Kubernetes
```