---
alwaysApply: true
---
QUY ∆Ø·ªöC PH√ÅT TRI·ªÇN PH·∫¶N M·ªÄM (TypeScript, NestJS, CQRS, TypeORM)
1. Nguy√™n T·∫Øc Ki·∫øn Tr√∫c C·ªët L√µi
Quy t·∫Øc n√†y ∆∞u ti√™n Kh·∫£ nƒÉng B·∫£o tr√¨ (Maintainability), Kh·∫£ nƒÉng Ki·ªÉm th·ª≠ (Testability), v√† Kh·∫£ nƒÉng M·ªü r·ªông (Scalability) b·∫±ng c√°ch √°p d·ª•ng Clean Architecture v√† Domain-Driven Design (DDD).

T√°ch bi·ªát Tr√°ch nhi·ªám (Separation of Concerns): Ph√¢n chia r√µ r√†ng logic nghi·ªáp v·ª• (Application Layer) kh·ªèi c√°c chi ti·∫øt k·ªπ thu·∫≠t (Infrastructure Layer).

Dependency Inversion Principle (DIP): L·ªõp c·∫•p cao kh√¥ng ƒë∆∞·ª£c ph·ª• thu·ªôc v√†o l·ªõp c·∫•p th·∫•p. C·∫£ hai ƒë·ªÅu ph·∫£i ph·ª• thu·ªôc v√†o Abstraction (TypeScript Interfaces ho·∫∑c Abstract Classes).

Dependency Injection (DI): Lu√¥n t·∫≠n d·ª•ng h·ªá th·ªëng DI c·ªßa NestJS. Kh√¥ng s·ª≠ d·ª•ng t·ª´ kh√≥a new ƒë·ªÉ t·∫°o dependencies (ngo·∫°i tr·ª´ Domain Entities thu·∫ßn t√∫y).

CQRS: T√°ch bi·ªát tri·ªát ƒë·ªÉ m√¥ h√¨nh Ghi (Write Model - Commands) v√† ƒê·ªçc (Read Model - Queries) ƒë·ªÉ t·ªëi ∆∞u h√≥a hi·ªáu su·∫•t v√† s·ª± ph·ª©c t·∫°p c·ªßa nghi·ªáp v·ª•.

2. C·∫•u Tr√∫c Th∆∞ M·ª•c D·ª± √Ån (Folder Structure)
C·∫•u tr√∫c d·ª± √°n tu√¢n th·ªß m√¥ h√¨nh Feature-Based Modules c·ªßa NestJS, n∆°i m·ªói module ƒë∆∞·ª£c ph√¢n l·ªõp theo ki·∫øn tr√∫c s·∫°ch (Clean Architecture) v√† CQRS.

src/
‚îú‚îÄ‚îÄ app.module.ts                   // Module g·ªëc
‚îú‚îÄ‚îÄ main.ts                         // Kh·ªüi ƒë·ªông ·ª©ng d·ª•ng

‚îú‚îÄ‚îÄ common/                         // Th∆∞ vi·ªán, ti·ªán √≠ch d√πng chung (Exceptions, Filters, Decorators)
‚îÇ   ‚îú‚îÄ‚îÄ filters/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ exception.filter.ts     // Global Exception Filter
‚îÇ   ‚îú‚îÄ‚îÄ interceptors/
‚îÇ   ‚îî‚îÄ‚îÄ dtos/

‚îú‚îÄ‚îÄ modules/                        // üí° T·ªî CH·ª®C THEO T√çNH NƒÇNG (Feature Modules)
‚îÇ   ‚îú‚îÄ‚îÄ user/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.module.ts          // G√≥i t·∫•t c·∫£ th√†nh ph·∫ßn c·ªßa t√≠nh nƒÉng "User"
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.controller.ts      // INTERFACE ADAPTERS (HTTP Handlers)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ domain/                 // 1. DOMAIN LAYER
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.entity.ts      // Domain Model (TypeORM Entity)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user.interface.ts   // Interface ƒë·ªãnh nghƒ©a c√°c quy t·∫Øc c·ªßa Entity
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ application/            // 2. APPLICATION LAYER (Use Cases/Business Logic)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ commands/           // 2a. WRITE LOGIC (CQRS - Commands)
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ impl/           // Command Handlers (s·ª≠a ƒë·ªïi tr·∫°ng th√°i)
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ create-user.handler.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ create-user.command.ts // Command DTO
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ create-user.dto.ts     // Request DTO cho Command
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ queries/            // 2b. READ LOGIC (CQRS - Queries)
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ impl/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ get-user-by-id.handler.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ get-user-by-id.query.ts  // Query DTO
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ get-user-by-id.dto.ts    // Request DTO cho Query
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ services/           // Business logic kh√¥ng thu·ªôc CQRS (v√≠ d·ª•: validation, mapping)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ infrastructure/         // 3. INFRASTRUCTURE LAYER
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ user.repository.ts // Tri·ªÉn khai TypeORM Repository (implements IUserRepository)
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ external/
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ notification.service.ts // G·ªçi External API/Message Queue
‚îÇ   ‚îî‚îÄ‚îÄ order/
‚îÇ       ‚îî‚îÄ‚îÄ ...
3. Quy ∆Ø·ªõc L·ªõp ·ª®ng D·ª•ng (Application Layer - CQRS)
L·ªõp n√†y ch·ª©a logic nghi·ªáp v·ª• c·ªët l√µi, ƒë∆∞·ª£c ph√¢n t√°ch th√†nh Commands v√† Queries.

3.1. Commands (T√°c v·ª• Ghi/Write Model)
M·ª•c ƒë√≠ch: Ch·ªâ ch·ªãu tr√°ch nhi·ªám thay ƒë·ªïi tr·∫°ng th√°i c·ªßa h·ªá th·ªëng (INSERT, UPDATE, DELETE).

Quy t·∫Øc ƒê·∫∑t t√™n: Ph·∫£i l√† ƒê·ªông t·ª´ + Danh t·ª´ v√† k·∫øt th√∫c b·∫±ng Command (v√≠ d·ª•: CreateUserCommand, DeactivateAccountCommand).

Handlers:

Ph·∫£i ƒë∆∞·ª£c ƒë·∫∑t trong th∆∞ m·ª•c commands/impl/.

S·ª≠ d·ª•ng Decorator @CommandHandler c·ªßa NestJS/CQRS.

N√™n g√≥i g·ªçn c√°c thao t√°c thay ƒë·ªïi d·ªØ li·ªáu trong Transaction ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh nguy√™n t·ª≠.

Kh√¥ng ƒë∆∞·ª£c tr·∫£ v·ªÅ Domain Entity, ch·ªâ n√™n tr·∫£ v·ªÅ m·ªôt ID, Status, ho·∫∑c void/true.

3.2. Queries (T√°c v·ª• ƒê·ªçc/Read Model)
M·ª•c ƒë√≠ch: Ch·ªâ ch·ªãu tr√°ch nhi·ªám truy xu·∫•t d·ªØ li·ªáu. Kh√¥ng bao gi·ªù ƒë∆∞·ª£c ph√©p thay ƒë·ªïi tr·∫°ng th√°i d·ªØ li·ªáu.

Quy t·∫Øc ƒê·∫∑t t√™n: Th∆∞·ªùng l√† Get...Query ho·∫∑c List...Query (v√≠ d·ª•: GetUserByIdQuery, ListAllOrdersQuery).

Handlers:

Ph·∫£i ƒë∆∞·ª£c ƒë·∫∑t trong th∆∞ m·ª•c queries/impl/.

S·ª≠ d·ª•ng Decorator @QueryHandler c·ªßa NestJS/CQRS.

C√≥ th·ªÉ truy v·∫•n tr·ª±c ti·∫øp c∆° s·ªü d·ªØ li·ªáu (v√≠ d·ª•: d√πng QueryBuilder c·ªßa TypeORM) ƒë·ªÉ t·ªëi ∆∞u h√≥a vi·ªác ƒë·ªçc.

Tr·∫£ v·ªÅ DTOs (Data Transfer Objects) thay v√¨ Domain Entities ƒë·ªÉ ki·ªÉm so√°t d·ªØ li·ªáu tr·∫£ v·ªÅ cho l·ªõp Interface Adapters.

3.3. DTOs v√† Validations
Request DTOs: S·ª≠ d·ª•ng c√°c l·ªõp DTO ri√™ng bi·ªát (trong th∆∞ m·ª•c dto/ ho·∫∑c c√πng th∆∞ m·ª•c v·ªõi Command/Query) cho vi·ªác nh·∫≠n d·ªØ li·ªáu t·ª´ Controller.

Validation: Lu√¥n s·ª≠ d·ª•ng class-validator v√† ValidationPipe to√†n c·ª•c c·ªßa NestJS ƒë·ªÉ x√°c th·ª±c d·ªØ li·ªáu ƒë·∫ßu v√†o.

4. Quy ∆Ø·ªõc D·ªØ Li·ªáu v√† C∆° s·ªü H·∫° t·∫ßng (TypeORM & Infrastructure)
4.1. Repositories
Abstraction (Interface): M·ªói Repository ph·∫£i ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a b·∫±ng m·ªôt Interface ho·∫∑c Abstract Class (v√≠ d·ª•: IUserRepository). Interface n√†y ƒë∆∞·ª£c ƒë·∫∑t trong l·ªõp Application ho·∫∑c Domain.

Implementation: L·ªõp tri·ªÉn khai TypeORM Repository (v√≠ d·ª•: UserRepository) ph·∫£i n·∫±m trong th∆∞ m·ª•c infrastructure/database v√† implements Interface ƒë√£ ƒë·ªãnh nghƒ©a.

DI Token: S·ª≠ d·ª•ng Interface l√†m DI Token ƒë·ªÉ c√°c Command/Query Handler ch·ªâ ph·ª• thu·ªôc v√†o Abstraction, kh√¥ng ph·ª• thu·ªôc v√†o TypeORM c·ª• th·ªÉ.

4.2. Domain Entities
C√°c l·ªõp TypeORM Entity (@Entity() classes) ƒë∆∞·ª£c ƒë·∫∑t trong th∆∞ m·ª•c domain/.

Ch√∫ng n√™n ch·ª©a c√°c h√†nh vi nghi·ªáp v·ª• (business methods) c·ªßa ch√≠nh n√≥, kh√¥ng ch·ªâ l√† c√°c tr∆∞·ªùng d·ªØ li·ªáu.

4.3. Qu·∫£n l√Ω Giao d·ªãch (Transactions)
Giao d·ªãch ph·∫£i ƒë∆∞·ª£c qu·∫£n l√Ω t·∫°i l·ªõp Command Handler.

S·ª≠ d·ª•ng Connection.transaction() c·ªßa TypeORM ho·∫∑c c√°c th∆∞ vi·ªán AOP (Aspect-Oriented Programming) ƒë·ªÉ qu·∫£n l√Ω giao d·ªãch m·ªôt c√°ch t∆∞·ªùng minh v√† an to√†n.

5. Quy ∆Ø·ªõc L·∫≠p tr√¨nh TypeScript & NestJS
5.1. TypeScript
Strict Typing: Lu√¥n b·∫≠t ch·∫ø ƒë·ªô strict: true trong tsconfig.json.

Interfaces: ∆Øu ti√™n s·ª≠ d·ª•ng TypeScript Interfaces cho vi·ªác ƒë·ªãnh nghƒ©a h·ª£p ƒë·ªìng c·ªßa Service, Repository, v√† DTOs.

Readonly: S·ª≠ d·ª•ng t·ª´ kh√≥a readonly cho c√°c thu·ªôc t√≠nh kh√¥ng ƒë∆∞·ª£c thay ƒë·ªïi sau khi kh·ªüi t·∫°o.

5.2. NestJS Conventions
Decorators: S·ª≠ d·ª•ng Decorators (@Injectable(), @Module(), v.v.) m·ªôt c√°ch ch√≠nh x√°c theo quy ∆∞·ªõc c·ªßa NestJS.

Providers: S·ª≠ d·ª•ng useClass, useFactory, ho·∫∑c useValue trong file *.module.ts ƒë·ªÉ c·∫•u h√¨nh Dependency Injection, ƒë·∫∑c bi·ªát l√† khi inject Repository Interface.

Pipes, Guards, Interceptors: T·∫≠n d·ª•ng t·ªëi ƒëa c√°c th√†nh ph·∫ßn n√†y ƒë·ªÉ x·ª≠ l√Ω c√°c v·∫•n ƒë·ªÅ xuy√™n su·ªët (cross-cutting concerns) nh∆∞ Validation, Authentication, Authorization, v√† Response Transformation.

6. X·ª≠ L√Ω L·ªói v√† Kh·∫£ nƒÉng Quan s√°t (Error Handling & Observability)
6.1. X·ª≠ L√Ω L·ªói C√≥ C·∫•u Tr√∫c (Standardized Error Handling)
Custom Base Exception (AppError):

ƒê·ªãnh nghƒ©a m·ªôt l·ªõp c∆° s·ªü AppError m·ªü r·ªông t·ª´ HttpException c·ªßa NestJS.

L·ªõp n√†y ph·∫£i ch·ª©a c√°c thu·ªôc t√≠nh ƒë·ªÉ ph√¢n lo·∫°i l·ªói: code (M√£ l·ªói nghi·ªáp v·ª•/h·ªá th·ªëng) v√† message (Th√¥ng ƒëi·ªáp l·ªói).

M√£ L·ªói Ti√™u Chu·∫©n: S·ª≠ d·ª•ng ph√¢n lo·∫°i m√£ l·ªói th·ªëng nh·∫•t:
| M√£ Ti·ªÅn t·ªë | √ù nghƒ©a | M√¥ t·∫£ |
| :--- | :--- | :--- |
| SYS | System | L·ªói h·ªá th·ªëng/c∆° s·ªü h·∫° t·∫ßng (v√≠ d·ª•: m·∫•t k·∫øt n·ªëi DB) |
| VAL | Validation | L·ªói x√°c th·ª±c d·ªØ li·ªáu ƒë·∫ßu v√†o |
| BIZ | Business | L·ªói logic nghi·ªáp v·ª• (v√≠ d·ª•: kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng) |
| AUTH | Authentication/Authorization | L·ªói li√™n quan ƒë·∫øn quy·ªÅn truy c·∫≠p |

Exception Filter: Tri·ªÉn khai Global Exception Filter ƒë·ªÉ b·∫Øt AppError v√† chu·∫©n h√≥a ph·∫£n h·ªìi API (tr·∫£ v·ªÅ JSON th·ªëng nh·∫•t) cho t·∫•t c·∫£ l·ªói.

6.2. Observability (Tracing, Logging, Metrics)
Distributed Tracing (Truy v·∫øt Ph√¢n t√°n):

S·ª≠ d·ª•ng OpenTelemetry ho·∫∑c th∆∞ vi·ªán t∆∞∆°ng ƒë∆∞∆°ng ƒë·ªÉ tri·ªÉn khai Tracing.

ƒê·∫£m b·∫£o m·ªói request ƒë∆∞·ª£c g√°n m·ªôt Trace ID duy nh·∫•t. Trace ID ph·∫£i ƒë∆∞·ª£c truy·ªÅn qua HTTP Headers (traceparent) v√† ƒë∆∞·ª£c ghi l·∫°i trong Logs.

Structured Logging:

S·ª≠ d·ª•ng logger c√≥ c·∫•u tr√∫c (v√≠ d·ª•: Pino ho·∫∑c Winston) t√≠ch h·ª£p v·ªõi NestJS.

Logs ph·∫£i l√† ƒë·ªãnh d·∫°ng JSON ƒë·ªÉ d·ªÖ d√†ng ph√¢n t√≠ch v√† truy v·∫•n.

Ghi l·∫°i th√¥ng tin c·∫ßn thi·∫øt: Trace ID, Span ID, Level, Timestamp, Message, Context (user ID, request path).

Metrics: S·ª≠ d·ª•ng Prometheus ho·∫∑c OpenTelemetry Metrics ƒë·ªÉ thu th·∫≠p c√°c s·ªë li·ªáu ch√≠nh (ƒë·ªô tr·ªÖ, t·ª∑ l·ªá l·ªói, th√¥ng l∆∞·ª£ng) t·ª´ Controller, Command/Query Handler, v√† External Call.

## 7. API Design & Kong Gateway Integration

### 7.1. RESTful API Standards
- S·ª≠ d·ª•ng **HTTP methods** ƒë√∫ng c√°ch: GET (read), POST (create), PUT (update), PATCH (partial update), DELETE (remove)
- Theo **resource-based URLs** v·ªõi API Gateway prefix: `/KONGAPI/api/v1/users/{id}` thay v√¨ `/api/v1/getUser`
- S·ª≠ d·ª•ng **plural nouns** cho collections: `/users`, `/orders`, `/products`
- Implement **proper HTTP status codes**: 200, 201, 400, 401, 403, 404, 409, 422, 500
- S·ª≠ d·ª•ng **consistent response format** v·ªõi envelope pattern v√† status code:
  ```json
  {
    "success": true,
    "status_code": 200,
    "data": {...},
    "meta": {
      "pagination": {...},
      "timestamp": "2024-01-15T10:30:00Z",
      "request_id": "req_123456789",
      "trace_id": "trace_987654321"
    }
  }
  ```

### 7.2. Kong Gateway Integration
- S·ª≠ d·ª•ng **KONGAPI prefix** cho t·∫•t c·∫£ public endpoints: `/KONGAPI/api/v1/...`
- Implement **Kong-specific headers** v√† **request routing**
- √Åp d·ª•ng **Kong middleware** cho authentication, rate limiting, v√† logging
- S·ª≠ d·ª•ng **Kong plugins** cho CORS, compression, v√† monitoring
- Implement **Kong health checks** v√† **service discovery**

#### Kong API URL Structure:
```
# Public API Endpoints (through Kong Gateway)
/KONGAPI/api/v1/users                    # GET, POST
/KONGAPI/api/v1/users/{id}               # GET, PUT, PATCH, DELETE
/KONGAPI/api/v1/orders                   # GET, POST
/KONGAPI/api/v1/orders/{id}              # GET, PUT, PATCH, DELETE
/KONGAPI/api/v1/products                 # GET, POST
/KONGAPI/api/v1/products/{id}            # GET, PUT, PATCH, DELETE

# Internal API Endpoints (direct access)
/api/v1/health                          # Health check
/api/v1/metrics                         # Prometheus metrics
/api/v1/ready                           # Readiness probe
```

### 7.3. NestJS Controller Configuration
```typescript
// Controller setup with Kong prefix
@Controller('KONGAPI/api/v1')
export class UserController {
  constructor(
    private readonly commandBus: CommandBus,
    private readonly queryBus: QueryBus,
  ) {}

  @Get('users')
  async getUsers(@Query() query: GetUsersDto) {
    return this.queryBus.execute(new GetUsersQuery(query));
  }

  @Post('users')
  async createUser(@Body() createUserDto: CreateUserDto) {
    return this.commandBus.execute(new CreateUserCommand(createUserDto));
  }

  @Get('users/:id')
  async getUser(@Param('id') id: string) {
    return this.queryBus.execute(new GetUserByIdQuery(id));
  }

  @Put('users/:id')
  async updateUser(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {
    return this.commandBus.execute(new UpdateUserCommand(id, updateUserDto));
  }

  @Delete('users/:id')
  async deleteUser(@Param('id') id: string) {
    return this.commandBus.execute(new DeleteUserCommand(id));
  }
}
```

## 8. Response Structure Standards

### 8.1. TypeScript Interface Definitions
```typescript
// Base Response Structure
export interface BaseResponse<T = any> {
  success: boolean;
  status_code: number;
  data?: T;
  meta?: Meta;
  error?: AppError;
}

// Meta Information
export interface Meta {
  pagination?: Pagination;
  timestamp: string;
  request_id?: string;
  trace_id?: string;
}

// Pagination Information
export interface Pagination {
  limit: number;
  offset: number;
  total: number;
  has_next: boolean;
  has_prev: boolean;
}

// Success Response Constructor
export class ResponseBuilder {
  static success<T>(data: T, statusCode: number = 200): BaseResponse<T> {
    return {
      success: true,
      status_code: statusCode,
      data,
      meta: {
        timestamp: new Date().toISOString(),
      },
    };
  }

  static error(error: AppError, statusCode: number): BaseResponse {
    return {
      success: false,
      status_code: statusCode,
      error,
      meta: {
        timestamp: new Date().toISOString(),
      },
    };
  }
}
```

### 8.2. HTTP Status Code Mapping
```typescript
// Success Status Codes
export const HTTP_STATUS = {
  OK: 200,                    // GET, PUT, PATCH success
  CREATED: 201,              // POST success
  ACCEPTED: 202,             // Async operation accepted
  NO_CONTENT: 204,           // DELETE success
  PARTIAL_CONTENT: 206,      // Partial GET success
} as const;

// Client Error Status Codes
export const HTTP_CLIENT_ERROR = {
  BAD_REQUEST: 400,          // Validation errors, malformed request
  UNAUTHORIZED: 401,         // Authentication required
  FORBIDDEN: 403,            // Insufficient permissions
  NOT_FOUND: 404,            // Resource not found
  METHOD_NOT_ALLOWED: 405,   // HTTP method not allowed
  CONFLICT: 409,             // Business rule conflict
  UNPROCESSABLE_ENTITY: 422, // Validation failed
  TOO_MANY_REQUESTS: 429,    // Rate limit exceeded
} as const;

// Server Error Status Codes
export const HTTP_SERVER_ERROR = {
  INTERNAL_SERVER_ERROR: 500, // Internal system error
  NOT_IMPLEMENTED: 501,       // Feature not implemented
  BAD_GATEWAY: 502,           // External service error
  SERVICE_UNAVAILABLE: 503,   // Service temporarily unavailable
  GATEWAY_TIMEOUT: 504,       // External service timeout
} as const;
```

### 8.3. Error Code to Status Code Mapping
```typescript
// Error Code to HTTP Status Code Mapping
export const ERROR_CODE_TO_STATUS_MAP: Record<string, number> = {
  // 1xxx - System Errors -> 500
  'SYS_001': 500, // Internal system error
  'SYS_002': 504, // Request timeout
  'SYS_003': 503, // Service unavailable
  
  // 2xxx - Validation Errors -> 400/422
  'VAL_001': 400, // Required field missing
  'VAL_002': 422, // Invalid format
  'VAL_003': 422, // Value out of range
  
  // 3xxx - Authentication/Authorization -> 401/403
  'AUTH_001': 401, // Invalid token
  'AUTH_002': 401, // Token expired
  'AUTH_003': 403, // Insufficient permissions
  
  // 4xxx - Business Logic -> 404/409/422
  'BIZ_001': 404, // Resource not found
  'BIZ_002': 409, // Business rule conflict
  'BIZ_003': 422, // Business limit exceeded
  
  // 5xxx - External Dependencies -> 502/503/504
  'EXT_001': 504, // External service timeout
  'EXT_002': 503, // External service unavailable
  'EXT_003': 502, // External service error
};

// Get HTTP Status Code from Error Code
export function getStatusFromErrorCode(errorCode: string): number {
  return ERROR_CODE_TO_STATUS_MAP[errorCode] || 500;
}
```

## 9. Authentication & Security

### 9.1. Kong Gateway Authentication Strategy

#### Kong Gateway Level Authentication:
- **Kong JWT Plugin** x·ª≠ l√Ω token validation ·ªü gateway level
- **No JWT plugin** = Kh√¥ng c·∫ßn authentication (public endpoints)
- **JWT plugin configured** = Authentication required (protected endpoints)
- **Kong validates JWT** tr∆∞·ªõc khi forward requests ƒë·∫øn NestJS application

#### NestJS Application Level:
- **Trust Kong's authentication** - Kong ƒë√£ validate token
- **Extract user info** t·ª´ Kong headers (X-Consumer-ID, X-Consumer-Username, etc.)
- **Kh√¥ng c·∫ßn re-validate JWT** trong NestJS application
- **Focus on authorization** (role-based access control)

### 9.2. Kong Middleware Integration
```typescript
// Kong Consumer Middleware - extracts consumer info from Kong headers
@Injectable()
export class KongConsumerMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    // Extract Kong headers (set by Kong JWT plugin)
    const kongRequestID = req.headers['x-kong-request-id'] as string;
    const kongConsumerID = req.headers['x-consumer-id'] as string;
    const kongConsumerUsername = req.headers['x-consumer-username'] as string;
    const kongConsumerCustomID = req.headers['x-consumer-custom-id'] as string;
    
    // Add to request context
    req['kong_request_id'] = kongRequestID;
    req['kong_consumer_id'] = kongConsumerID;
    req['kong_consumer_username'] = kongConsumerUsername;
    req['kong_consumer_custom_id'] = kongConsumerCustomID;
    
    // Log Kong-specific information
    console.log('Kong authenticated request', {
      kong_request_id: kongRequestID,
      kong_consumer_id: kongConsumerID,
      kong_consumer_username: kongConsumerUsername,
      path: req.url,
      method: req.method,
    });
    
    next();
  }
}

// Kong Public Middleware (for Public Endpoints)
@Injectable()
export class KongPublicMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    // Extract Kong headers (may or may not be present for public endpoints)
    const kongRequestID = req.headers['x-kong-request-id'] as string;
    
    // Add to request context
    req['kong_request_id'] = kongRequestID;
    
    // Log public request
    console.log('Kong public request', {
      kong_request_id: kongRequestID,
      path: req.url,
      method: req.method,
    });
    
    next();
  }
}
```

### 9.3. Authentication Requirements by Endpoint Type

#### Public Endpoints (No Kong JWT Plugin - No Authentication Required):
```typescript
// Public endpoints - NO JWT plugin in Kong configuration
@Controller('KONGAPI/api/v1/public')
export class PublicController {
  // Health and monitoring
  @Get('health')
  async healthCheck() {
    return ResponseBuilder.success({ status: 'healthy' });
  }

  @Get('ready')
  async readinessCheck() {
    return ResponseBuilder.success({ status: 'ready' });
  }

  // Authentication endpoints
  @Post('auth/login')
  async login(@Body() loginDto: LoginDto) {
    return this.commandBus.execute(new LoginCommand(loginDto));
  }

  @Post('auth/register')
  async register(@Body() registerDto: RegisterDto) {
    return this.commandBus.execute(new RegisterCommand(registerDto));
  }
}
```

#### Protected Endpoints (Kong JWT Plugin Required):
```typescript
// Protected endpoints - Kong JWT plugin validates token before reaching NestJS app
@Controller('KONGAPI/api/v1')
@UseGuards(KongConsumerGuard) // Extract consumer info from Kong headers
export class UserController {
  constructor(
    private readonly commandBus: CommandBus,
    private readonly queryBus: QueryBus,
  ) {}

  @Get('users')
  async getUsers(@Query() query: GetUsersDto) {
    return this.queryBus.execute(new GetUsersQuery(query));
  }

  @Post('users')
  async createUser(@Body() createUserDto: CreateUserDto) {
    return this.commandBus.execute(new CreateUserCommand(createUserDto));
  }
}
```

### 9.4. Role-based Authorization
```typescript
// Role-based Authorization Guard
@Injectable()
export class RoleGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<string[]>('roles', [
      context.getHandler(),
      context.getClass(),
    ]);

    if (!requiredRoles) {
      return true;
    }

    const request = context.switchToHttp().getRequest();
    const userRole = request['user_role'] || request.headers['x-user-role'];

    return requiredRoles.some((role) => userRole === role);
  }
}

// Usage in Controller
@Controller('KONGAPI/api/v1/admin')
@UseGuards(KongConsumerGuard, RoleGuard)
@Roles('admin')
export class AdminController {
  @Get('users')
  async getAllUsers() {
    return this.queryBus.execute(new GetAllUsersQuery());
  }
}
```

## 10. Database Best Practices v·ªõi TypeORM

### 10.1. Database Naming Conventions

#### Table Naming Standards:
- **T·∫•t c·∫£ tables** ph·∫£i b·∫Øt ƒë·∫ßu v·ªõi prefix `BMM_`
- S·ª≠ d·ª•ng **UPPERCASE** cho t·∫•t c·∫£ table names
- S·ª≠ d·ª•ng **UNDERSCORE** ƒë·ªÉ ph√¢n t√°ch t·ª´
- S·ª≠ d·ª•ng **SINGULAR** table names
- V√≠ d·ª•: `BMM_USERS`, `BMM_ORDERS`, `BMM_PRODUCTS`

#### Column Naming Standards:
- **T·∫•t c·∫£ columns** ph·∫£i s·ª≠ d·ª•ng **UPPERCASE**
- S·ª≠ d·ª•ng **UNDERSCORE** ƒë·ªÉ ph√¢n t√°ch t·ª´
- S·ª≠ d·ª•ng **descriptive** column names
- V√≠ d·ª•: `USER_ID`, `CREATED_AT`, `UPDATED_AT`, `FIRST_NAME`, `LAST_NAME`

#### Index Naming Standards:
- **Primary Key**: `PK_BMM_TABLENAME` (v√≠ d·ª•: `PK_BMM_USERS`)
- **Unique Index**: `UK_BMM_TABLENAME_COLUMN` (v√≠ d·ª•: `UK_BMM_USERS_USERNAME`)
- **Foreign Key**: `FK_BMM_TABLENAME_REFERENCEDTABLE` (v√≠ d·ª•: `FK_BMM_ORDERS_BMM_USERS`)
- **Regular Index**: `IDX_BMM_TABLENAME_COLUMN` (v√≠ d·ª•: `IDX_BMM_USERS_EMAIL`)

### 10.2. Entity Design Standards
```typescript
// Base Entity v·ªõi common fields
@Entity('BMM_BASE_ENTITY')
export abstract class BaseEntity {
  @PrimaryGeneratedColumn('uuid')
  @Column({ name: 'ID', type: 'uuid' })
  id: string;

  @CreateDateColumn({ name: 'CREATED_AT' })
  createdAt: Date;

  @UpdateDateColumn({ name: 'UPDATED_AT' })
  updatedAt: Date;

  @DeleteDateColumn({ name: 'DELETED_AT', nullable: true })
  deletedAt?: Date;

  @Column({ name: 'CREATED_BY', nullable: true })
  createdBy?: string;

  @Column({ name: 'UPDATED_BY', nullable: true })
  updatedBy?: string;

  @VersionColumn({ name: 'VERSION' })
  version: number;
}

// User Entity example
@Entity('BMM_USERS')
export class User extends BaseEntity {
  @Column({ name: 'USERNAME', unique: true })
  username: string;

  @Column({ name: 'EMAIL', unique: true })
  email: string;

  @Column({ name: 'PASSWORD_HASH' })
  passwordHash: string;

  @Column({ name: 'FIRST_NAME' })
  firstName: string;

  @Column({ name: 'LAST_NAME' })
  lastName: string;

  @Column({ name: 'IS_ACTIVE', default: true })
  isActive: boolean;

  @Column({ name: 'PHONE_NUMBER', nullable: true })
  phoneNumber?: string;

  @Column({ name: 'DATE_OF_BIRTH', type: 'date', nullable: true })
  dateOfBirth?: Date;

  @Column({ name: 'ADDRESS', type: 'text', nullable: true })
  address?: string;

  // Business methods
  getFullName(): string {
    return `${this.firstName} ${this.lastName}`;
  }

  isAccountActive(): boolean {
    return this.isActive && !this.deletedAt;
  }
}

// Order Entity example v·ªõi relationships
@Entity('BMM_ORDERS')
export class Order extends BaseEntity {
  @Column({ name: 'ORDER_NUMBER', unique: true })
  orderNumber: string;

  @Column({ name: 'USER_ID', type: 'uuid' })
  userId: string;

  @Column({ name: 'TOTAL_AMOUNT', type: 'decimal', precision: 10, scale: 2 })
  totalAmount: number;

  @Column({ name: 'STATUS', default: 'PENDING' })
  status: string;

  @Column({ name: 'ORDER_DATE', type: 'timestamp' })
  orderDate: Date;

  @Column({ name: 'SHIPPING_ADDRESS', type: 'text' })
  shippingAddress: string;

  @Column({ name: 'NOTES', type: 'text', nullable: true })
  notes?: string;

  // Relationships
  @ManyToOne(() => User, user => user.orders)
  @JoinColumn({ name: 'USER_ID' })
  user: User;

  @OneToMany(() => OrderItem, orderItem => orderItem.order)
  orderItems: OrderItem[];

  // Business methods
  calculateTotal(): number {
    return this.orderItems?.reduce((total, item) => total + item.subtotal, 0) || 0;
  }

  isCompleted(): boolean {
    return this.status === 'COMPLETED';
  }
}

// OrderItem Entity example
@Entity('BMM_ORDER_ITEMS')
export class OrderItem extends BaseEntity {
  @Column({ name: 'ORDER_ID', type: 'uuid' })
  orderId: string;

  @Column({ name: 'PRODUCT_ID', type: 'uuid' })
  productId: string;

  @Column({ name: 'QUANTITY', type: 'int' })
  quantity: number;

  @Column({ name: 'UNIT_PRICE', type: 'decimal', precision: 10, scale: 2 })
  unitPrice: number;

  @Column({ name: 'SUBTOTAL', type: 'decimal', precision: 10, scale: 2 })
  subtotal: number;

  // Relationships
  @ManyToOne(() => Order, order => order.orderItems)
  @JoinColumn({ name: 'ORDER_ID' })
  order: Order;

  @ManyToOne(() => Product)
  @JoinColumn({ name: 'PRODUCT_ID' })
  product: Product;

  // Business methods
  calculateSubtotal(): number {
    return this.quantity * this.unitPrice;
  }
}

// Product Entity example
@Entity('BMM_PRODUCTS')
export class Product extends BaseEntity {
  @Column({ name: 'PRODUCT_CODE', unique: true })
  productCode: string;

  @Column({ name: 'PRODUCT_NAME' })
  productName: string;

  @Column({ name: 'DESCRIPTION', type: 'text', nullable: true })
  description?: string;

  @Column({ name: 'PRICE', type: 'decimal', precision: 10, scale: 2 })
  price: number;

  @Column({ name: 'STOCK_QUANTITY', type: 'int', default: 0 })
  stockQuantity: number;

  @Column({ name: 'CATEGORY_ID', type: 'uuid', nullable: true })
  categoryId?: string;

  @Column({ name: 'IS_ACTIVE', default: true })
  isActive: boolean;

  // Relationships
  @ManyToOne(() => Category)
  @JoinColumn({ name: 'CATEGORY_ID' })
  category?: Category;

  // Business methods
  isInStock(): boolean {
    return this.stockQuantity > 0;
  }

  isAvailable(): boolean {
    return this.isActive && this.isInStock();
  }
}

// Category Entity example
@Entity('BMM_CATEGORIES')
export class Category extends BaseEntity {
  @Column({ name: 'CATEGORY_NAME' })
  categoryName: string;

  @Column({ name: 'DESCRIPTION', type: 'text', nullable: true })
  description?: string;

  @Column({ name: 'PARENT_CATEGORY_ID', type: 'uuid', nullable: true })
  parentCategoryId?: string;

  @Column({ name: 'IS_ACTIVE', default: true })
  isActive: boolean;

  // Relationships
  @ManyToOne(() => Category, category => category.subCategories)
  @JoinColumn({ name: 'PARENT_CATEGORY_ID' })
  parentCategory?: Category;

  @OneToMany(() => Category, category => category.parentCategory)
  subCategories: Category[];

  @OneToMany(() => Product, product => product.category)
  products: Product[];
}
```

### 10.2. Repository Pattern v·ªõi TypeORM
```typescript
// Repository Interface (Domain Layer)
export interface IUserRepository {
  findById(id: string): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
  findByUsername(username: string): Promise<User | null>;
  save(user: User): Promise<User>;
  delete(id: string): Promise<void>;
  findActiveUsers(limit: number, offset: number): Promise<[User[], number]>;
}

// Repository Implementation (Infrastructure Layer)
@Injectable()
export class UserRepository implements IUserRepository {
  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
  ) {}

  async findById(id: string): Promise<User | null> {
    return this.userRepository.findOne({
      where: { id, deletedAt: IsNull() },
    });
  }

  async findByEmail(email: string): Promise<User | null> {
    return this.userRepository.findOne({
      where: { email, deletedAt: IsNull() },
    });
  }

  async findByUsername(username: string): Promise<User | null> {
    return this.userRepository.findOne({
      where: { username, deletedAt: IsNull() },
    });
  }

  async save(user: User): Promise<User> {
    return this.userRepository.save(user);
  }

  async delete(id: string): Promise<void> {
    await this.userRepository.softDelete(id);
  }

  async findActiveUsers(limit: number, offset: number): Promise<[User[], number]> {
    return this.userRepository.findAndCount({
      where: { isActive: true, deletedAt: IsNull() },
      take: limit,
      skip: offset,
      order: { createdAt: 'DESC' },
    });
  }
}
```

### 10.3. Transaction Management
```typescript
// Command Handler v·ªõi Transaction
@CommandHandler(CreateUserCommand)
export class CreateUserHandler implements ICommandHandler<CreateUserCommand> {
  constructor(
    @Inject('IUserRepository')
    private readonly userRepository: IUserRepository,
    @Inject('INotificationService')
    private readonly notificationService: INotificationService,
    private readonly dataSource: DataSource,
  ) {}

  async execute(command: CreateUserCommand): Promise<User> {
    return this.dataSource.transaction(async (manager) => {
      // Create user
      const user = new User();
      user.username = command.username;
      user.email = command.email;
      user.passwordHash = await this.hashPassword(command.password);
      user.firstName = command.firstName;
      user.lastName = command.lastName;

      const savedUser = await manager.save(User, user);

      // Send welcome notification (async)
      this.notificationService.sendWelcomeEmail(savedUser.email).catch((error) => {
        console.error('Failed to send welcome email:', error);
      });

      return savedUser;
    });
  }

  private async hashPassword(password: string): Promise<string> {
    // Implementation for password hashing
    return password; // Simplified for example
  }
}
```

### 10.4. Query Optimization v·ªõi TypeORM
```typescript
// Query Handler v·ªõi optimized queries
@QueryHandler(GetUsersQuery)
export class GetUsersHandler implements IQueryHandler<GetUsersQuery> {
  constructor(
    @Inject('IUserRepository')
    private readonly userRepository: IUserRepository,
  ) {}

  async execute(query: GetUsersQuery): Promise<GetUsersResult> {
    const { limit = 10, offset = 0, search, status } = query;

    const queryBuilder = this.userRepository
      .createQueryBuilder('user')
      .where('user.deletedAt IS NULL')
      .orderBy('user.createdAt', 'DESC')
      .limit(limit)
      .offset(offset);

    // Add search condition
    if (search) {
      queryBuilder.andWhere(
        '(user.firstName ILIKE :search OR user.lastName ILIKE :search OR user.email ILIKE :search)',
        { search: `%${search}%` }
      );
    }

    // Add status filter
    if (status !== undefined) {
      queryBuilder.andWhere('user.isActive = :status', { status });
    }

    const [users, total] = await queryBuilder.getManyAndCount();

    return {
      users: users.map(user => ({
        id: user.id,
        username: user.username,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        fullName: user.getFullName(),
        isActive: user.isActive,
        createdAt: user.createdAt,
      })),
      total,
      limit,
      offset,
    };
  }
}
```

### 10.5. Database Migration Examples
```sql
-- Migration: 001_create_bmm_users_table.sql
CREATE TABLE BMM_USERS (
    ID UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    USERNAME VARCHAR(50) NOT NULL UNIQUE,
    EMAIL VARCHAR(100) NOT NULL UNIQUE,
    PASSWORD_HASH VARCHAR(255) NOT NULL,
    FIRST_NAME VARCHAR(50) NOT NULL,
    LAST_NAME VARCHAR(50) NOT NULL,
    PHONE_NUMBER VARCHAR(20),
    DATE_OF_BIRTH DATE,
    ADDRESS TEXT,
    IS_ACTIVE BOOLEAN DEFAULT TRUE,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    DELETED_AT TIMESTAMP NULL,
    CREATED_BY VARCHAR(50),
    UPDATED_BY VARCHAR(50),
    VERSION INTEGER DEFAULT 1
);

-- Indexes for BMM_USERS
CREATE INDEX IDX_BMM_USERS_EMAIL ON BMM_USERS(EMAIL);
CREATE INDEX IDX_BMM_USERS_USERNAME ON BMM_USERS(USERNAME);
CREATE INDEX IDX_BMM_USERS_IS_ACTIVE ON BMM_USERS(IS_ACTIVE);
CREATE INDEX IDX_BMM_USERS_CREATED_AT ON BMM_USERS(CREATED_AT);

-- Migration: 002_create_bmm_categories_table.sql
CREATE TABLE BMM_CATEGORIES (
    ID UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    CATEGORY_NAME VARCHAR(100) NOT NULL,
    DESCRIPTION TEXT,
    PARENT_CATEGORY_ID UUID,
    IS_ACTIVE BOOLEAN DEFAULT TRUE,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    DELETED_AT TIMESTAMP NULL,
    CREATED_BY VARCHAR(50),
    UPDATED_BY VARCHAR(50),
    VERSION INTEGER DEFAULT 1,
    
    CONSTRAINT FK_BMM_CATEGORIES_BMM_CATEGORIES 
        FOREIGN KEY (PARENT_CATEGORY_ID) 
        REFERENCES BMM_CATEGORIES(ID)
);

-- Indexes for BMM_CATEGORIES
CREATE INDEX IDX_BMM_CATEGORIES_CATEGORY_NAME ON BMM_CATEGORIES(CATEGORY_NAME);
CREATE INDEX IDX_BMM_CATEGORIES_PARENT_CATEGORY_ID ON BMM_CATEGORIES(PARENT_CATEGORY_ID);
CREATE INDEX IDX_BMM_CATEGORIES_IS_ACTIVE ON BMM_CATEGORIES(IS_ACTIVE);

-- Migration: 003_create_bmm_products_table.sql
CREATE TABLE BMM_PRODUCTS (
    ID UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    PRODUCT_CODE VARCHAR(50) NOT NULL UNIQUE,
    PRODUCT_NAME VARCHAR(200) NOT NULL,
    DESCRIPTION TEXT,
    PRICE DECIMAL(10,2) NOT NULL,
    STOCK_QUANTITY INTEGER DEFAULT 0,
    CATEGORY_ID UUID,
    IS_ACTIVE BOOLEAN DEFAULT TRUE,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    DELETED_AT TIMESTAMP NULL,
    CREATED_BY VARCHAR(50),
    UPDATED_BY VARCHAR(50),
    VERSION INTEGER DEFAULT 1,
    
    CONSTRAINT FK_BMM_PRODUCTS_BMM_CATEGORIES 
        FOREIGN KEY (CATEGORY_ID) 
        REFERENCES BMM_CATEGORIES(ID)
);

-- Indexes for BMM_PRODUCTS
CREATE INDEX IDX_BMM_PRODUCTS_PRODUCT_CODE ON BMM_PRODUCTS(PRODUCT_CODE);
CREATE INDEX IDX_BMM_PRODUCTS_PRODUCT_NAME ON BMM_PRODUCTS(PRODUCT_NAME);
CREATE INDEX IDX_BMM_PRODUCTS_CATEGORY_ID ON BMM_PRODUCTS(CATEGORY_ID);
CREATE INDEX IDX_BMM_PRODUCTS_IS_ACTIVE ON BMM_PRODUCTS(IS_ACTIVE);
CREATE INDEX IDX_BMM_PRODUCTS_STOCK_QUANTITY ON BMM_PRODUCTS(STOCK_QUANTITY);

-- Migration: 004_create_bmm_orders_table.sql
CREATE TABLE BMM_ORDERS (
    ID UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ORDER_NUMBER VARCHAR(50) NOT NULL UNIQUE,
    USER_ID UUID NOT NULL,
    TOTAL_AMOUNT DECIMAL(10,2) NOT NULL,
    STATUS VARCHAR(20) DEFAULT 'PENDING',
    ORDER_DATE TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    SHIPPING_ADDRESS TEXT NOT NULL,
    NOTES TEXT,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    DELETED_AT TIMESTAMP NULL,
    CREATED_BY VARCHAR(50),
    UPDATED_BY VARCHAR(50),
    VERSION INTEGER DEFAULT 1,
    
    CONSTRAINT FK_BMM_ORDERS_BMM_USERS 
        FOREIGN KEY (USER_ID) 
        REFERENCES BMM_USERS(ID)
);

-- Indexes for BMM_ORDERS
CREATE INDEX IDX_BMM_ORDERS_ORDER_NUMBER ON BMM_ORDERS(ORDER_NUMBER);
CREATE INDEX IDX_BMM_ORDERS_USER_ID ON BMM_ORDERS(USER_ID);
CREATE INDEX IDX_BMM_ORDERS_STATUS ON BMM_ORDERS(STATUS);
CREATE INDEX IDX_BMM_ORDERS_ORDER_DATE ON BMM_ORDERS(ORDER_DATE);

-- Migration: 005_create_bmm_order_items_table.sql
CREATE TABLE BMM_ORDER_ITEMS (
    ID UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ORDER_ID UUID NOT NULL,
    PRODUCT_ID UUID NOT NULL,
    QUANTITY INTEGER NOT NULL,
    UNIT_PRICE DECIMAL(10,2) NOT NULL,
    SUBTOTAL DECIMAL(10,2) NOT NULL,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    DELETED_AT TIMESTAMP NULL,
    CREATED_BY VARCHAR(50),
    UPDATED_BY VARCHAR(50),
    VERSION INTEGER DEFAULT 1,
    
    CONSTRAINT FK_BMM_ORDER_ITEMS_BMM_ORDERS 
        FOREIGN KEY (ORDER_ID) 
        REFERENCES BMM_ORDERS(ID),
    CONSTRAINT FK_BMM_ORDER_ITEMS_BMM_PRODUCTS 
        FOREIGN KEY (PRODUCT_ID) 
        REFERENCES BMM_PRODUCTS(ID)
);

-- Indexes for BMM_ORDER_ITEMS
CREATE INDEX IDX_BMM_ORDER_ITEMS_ORDER_ID ON BMM_ORDER_ITEMS(ORDER_ID);
CREATE INDEX IDX_BMM_ORDER_ITEMS_PRODUCT_ID ON BMM_ORDER_ITEMS(PRODUCT_ID);
```

### 10.6. TypeORM Configuration v·ªõi BMM_ Naming
```typescript
// TypeORM Configuration
export const typeOrmConfig: TypeOrmModuleOptions = {
  type: 'postgres',
  host: process.env.DATABASE_HOST || 'localhost',
  port: parseInt(process.env.DATABASE_PORT) || 5432,
  username: process.env.DATABASE_USER || 'postgres',
  password: process.env.DATABASE_PASSWORD || 'password',
  database: process.env.DATABASE_NAME || 'bmm_db',
  entities: [User, Order, OrderItem, Product, Category],
  synchronize: process.env.NODE_ENV === 'development',
  logging: process.env.NODE_ENV === 'development',
  namingStrategy: new SnakeNamingStrategy(), // Converts camelCase to snake_case
  migrations: ['dist/migrations/*.js'],
  migrationsRun: true,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
};

// Custom Naming Strategy ƒë·ªÉ handle BMM_ prefix
export class BMMNamingStrategy extends SnakeNamingStrategy {
  tableName(className: string, customName?: string): string {
    if (customName) {
      return customName;
    }
    // Convert ClassName to BMM_TABLE_NAME format
    const snakeCase = className.replace(/([A-Z])/g, '_$1').toLowerCase();
    return `BMM_${snakeCase.substring(1).toUpperCase()}`;
  }

  columnName(propertyName: string, customName?: string, embeddedPrefixes: string[] = []): string {
    if (customName) {
      return customName;
    }
    // Convert propertyName to COLUMN_NAME format
    const snakeCase = propertyName.replace(/([A-Z])/g, '_$1').toLowerCase();
    return snakeCase.substring(1).toUpperCase();
  }

  indexName(tableOrName: string, columns: string[], where?: string): string {
    const tableName = typeof tableOrName === 'string' ? tableOrName : tableOrName.name;
    const columnNames = columns.join('_');
    return `IDX_${tableName}_${columnNames}`;
  }

  primaryKeyName(tableOrName: string, columnNames: string[]): string {
    const tableName = typeof tableOrName === 'string' ? tableOrName : tableOrName.name;
    return `PK_${tableName}`;
  }

  uniqueConstraintName(tableOrName: string, columnNames: string[]): string {
    const tableName = typeof tableOrName === 'string' ? tableOrName : tableOrName.name;
    const columnNamesStr = columnNames.join('_');
    return `UK_${tableName}_${columnNamesStr}`;
  }

  foreignKeyName(tableOrName: string, columnNames: string[], referencedTablePath?: string, referencedColumnNames?: string[]): string {
    const tableName = typeof tableOrName === 'string' ? tableOrName : tableOrName.name;
    const referencedTableName = referencedTablePath?.split('.').pop();
    return `FK_${tableName}_${referencedTableName}`;
  }
}
```

## 11. Testing & Quality Assurance

### 11.1. Unit Testing v·ªõi Jest
```typescript
// Command Handler Test
describe('CreateUserHandler', () => {
  let handler: CreateUserHandler;
  let userRepository: jest.Mocked<IUserRepository>;
  let dataSource: jest.Mocked<DataSource>;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        CreateUserHandler,
        {
          provide: 'IUserRepository',
          useValue: {
            save: jest.fn(),
            findByEmail: jest.fn(),
          },
        },
        {
          provide: DataSource,
          useValue: {
            transaction: jest.fn(),
          },
        },
      ],
    }).compile();

    handler = module.get<CreateUserHandler>(CreateUserHandler);
    userRepository = module.get('IUserRepository');
    dataSource = module.get(DataSource);
  });

  it('should create user successfully', async () => {
    // Arrange
    const command = new CreateUserCommand({
      username: 'testuser',
      email: 'test@example.com',
      password: 'password123',
      firstName: 'Test',
      lastName: 'User',
    });

    const mockUser = new User();
    mockUser.id = 'user-id';
    mockUser.username = command.username;

    userRepository.findByEmail.mockResolvedValue(null);
    dataSource.transaction.mockImplementation(async (callback) => {
      return callback({
        save: jest.fn().mockResolvedValue(mockUser),
      });
    });

    // Act
    const result = await handler.execute(command);

    // Assert
    expect(result).toBeDefined();
    expect(result.username).toBe(command.username);
    expect(userRepository.findByEmail).toHaveBeenCalledWith(command.email);
  });

  it('should throw error if email already exists', async () => {
    // Arrange
    const command = new CreateUserCommand({
      username: 'testuser',
      email: 'existing@example.com',
      password: 'password123',
      firstName: 'Test',
      lastName: 'User',
    });

    const existingUser = new User();
    userRepository.findByEmail.mockResolvedValue(existingUser);

    // Act & Assert
    await expect(handler.execute(command)).rejects.toThrow('Email already exists');
  });
});
```

### 11.2. Integration Testing
```typescript
// Integration Test
describe('UserController (Integration)', () => {
  let app: INestApplication;
  let userRepository: Repository<User>;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [
        AppModule,
        TypeOrmModule.forRoot({
          type: 'postgres',
          host: 'localhost',
          port: 5432,
          username: 'test',
          password: 'test',
          database: 'test_db',
          entities: [User],
          synchronize: true,
        }),
      ],
    }).compile();

    app = moduleFixture.createNestApplication();
    userRepository = moduleFixture.get<Repository<User>>(getRepositoryToken(User));
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  beforeEach(async () => {
    await userRepository.clear();
  });

  it('POST /KONGAPI/api/v1/users should create user', async () => {
    // Arrange
    const createUserDto = {
      username: 'testuser',
      email: 'test@example.com',
      password: 'password123',
      firstName: 'Test',
      lastName: 'User',
    };

    // Act
    const response = await request(app.getHttpServer())
      .post('/KONGAPI/api/v1/users')
      .send(createUserDto)
      .expect(201);

    // Assert
    expect(response.body.success).toBe(true);
    expect(response.body.data.username).toBe(createUserDto.username);

    // Verify in database
    const user = await userRepository.findOne({
      where: { username: createUserDto.username },
    });
    expect(user).toBeDefined();
  });

  it('GET /KONGAPI/api/v1/users should return users list', async () => {
    // Arrange
    const user = new User();
    user.username = 'testuser';
    user.email = 'test@example.com';
    user.passwordHash = 'hashed';
    user.firstName = 'Test';
    user.lastName = 'User';
    await userRepository.save(user);

    // Act
    const response = await request(app.getHttpServer())
      .get('/KONGAPI/api/v1/users')
      .expect(200);

    // Assert
    expect(response.body.success).toBe(true);
    expect(response.body.data.users).toHaveLength(1);
    expect(response.body.data.users[0].username).toBe('testuser');
  });
});
```

### 11.3. E2E Testing
```typescript
// E2E Test
describe('User E2E', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  it('/KONGAPI/api/v1/users (POST)', () => {
    return request(app.getHttpServer())
      .post('/KONGAPI/api/v1/users')
      .send({
        username: 'e2euser',
        email: 'e2e@example.com',
        password: 'password123',
        firstName: 'E2E',
        lastName: 'User',
      })
      .expect(201)
      .expect((res) => {
        expect(res.body.success).toBe(true);
        expect(res.body.data.username).toBe('e2euser');
      });
  });

  it('/KONGAPI/api/v1/users (GET)', () => {
    return request(app.getHttpServer())
      .get('/KONGAPI/api/v1/users')
      .expect(200)
      .expect((res) => {
        expect(res.body.success).toBe(true);
        expect(Array.isArray(res.body.data.users)).toBe(true);
      });
  });
});
```

### 11.4. Code Quality Standards
```typescript
// ESLint Configuration (.eslintrc.js)
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    '@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'error',
    '@typescript-eslint/no-unused-vars': 'error',
    'prefer-const': 'error',
    'no-var': 'error',
  },
};

// Prettier Configuration (.prettierrc)
{
  "singleQuote": true,
  "trailingComma": "all",
  "tabWidth": 2,
  "semi": true,
  "printWidth": 100
}

// Jest Configuration (jest.config.js)
module.exports = {
  moduleFileExtensions: ['js', 'json', 'ts'],
  rootDir: 'src',
  testRegex: '.*\\.spec\\.ts$',
  transform: {
    '^.+\\.(t|j)s$': 'ts-jest',
  },
  collectCoverageFrom: [
    '**/*.(t|j)s',
    '!**/*.spec.ts',
    '!**/*.interface.ts',
    '!**/node_modules/**',
  ],
  coverageDirectory: '../coverage',
  testEnvironment: 'node',
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
};
```

## 12. Deployment & DevOps

### 12.1. Docker Configuration
```dockerfile
# Multi-stage Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./
COPY tsconfig*.json ./

# Install dependencies
RUN npm ci --only=production && npm cache clean --force

# Copy source code
COPY src/ ./src/

# Build application
RUN npm run build

# Production stage
FROM node:18-alpine AS production

WORKDIR /app

# Install dumb-init for proper signal handling
RUN apk add --no-cache dumb-init

# Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nestjs -u 1001

# Copy built application
COPY --from=builder --chown=nestjs:nodejs /app/dist ./dist
COPY --from=builder --chown=nestjs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nestjs:nodejs /app/package*.json ./

# Switch to non-root user
USER nestjs

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/api/v1/health || exit 1

# Start application
ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "dist/main.js"]
```

### 12.2. Docker Compose
```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_HOST=postgres
      - DATABASE_PORT=5432
      - DATABASE_NAME=app_db
      - DATABASE_USER=app_user
      - DATABASE_PASSWORD=app_password
      - REDIS_HOST=redis
      - REDIS_PORT=6379
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/api/v1/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=app_db
      - POSTGRES_USER=app_user
      - POSTGRES_PASSWORD=app_password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./migrations:/docker-entrypoint-initdb.d
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U app_user -d app_db"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - app
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
```

### 12.3. Kubernetes Deployment
```yaml
# k8s-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nestjs-app
  labels:
    app: nestjs-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nestjs-app
  template:
    metadata:
      labels:
        app: nestjs-app
    spec:
      containers:
      - name: nestjs-app
        image: your-registry/nestjs-app:latest
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "production"
        - name: DATABASE_HOST
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: database-host
        - name: DATABASE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: database-password
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /api/v1/health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /api/v1/ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
        securityContext:
          runAsNonRoot: true
          runAsUser: 1001
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL

---
apiVersion: v1
kind: Service
metadata:
  name: nestjs-app-service
spec:
  selector:
    app: nestjs-app
  ports:
  - protocol: TCP
    port: 80
    targetPort: 3000
  type: ClusterIP

---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: nestjs-app-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  tls:
  - hosts:
    - api.yourdomain.com
    secretName: nestjs-app-tls
  rules:
  - host: api.yourdomain.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: nestjs-app-service
            port:
              number: 80
```

### 12.4. CI/CD Pipeline (GitHub Actions)
```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
    - uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run linting
      run: npm run lint

    - name: Run type checking
      run: npm run type-check

    - name: Run unit tests
      run: npm run test:unit
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
        REDIS_URL: redis://localhost:6379

    - name: Run integration tests
      run: npm run test:integration
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
        REDIS_URL: redis://localhost:6379

    - name: Generate coverage report
      run: npm run test:cov

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Build application
      run: npm run build

    - name: Log in to Container Registry
      uses: docker/login-action@v2
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v4
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}

    - name: Deploy to Kubernetes
      uses: azure/k8s-deploy@v1
      with:
        manifests: |
          k8s-deployment.yaml
        images: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
```

### 12.5. Monitoring & Observability
```typescript
// Health Check Controller
@Controller('api/v1')
export class HealthController {
  constructor(
    private readonly health: HealthCheckService,
    private readonly db: TypeOrmHealthIndicator,
    private readonly redis: RedisHealthIndicator,
  ) {}

  @Get('health')
  @HealthCheck()
  check() {
    return this.health.check([
      () => this.db.pingCheck('database'),
      () => this.redis.pingCheck('redis'),
    ]);
  }

  @Get('ready')
  @HealthCheck()
  readiness() {
    return this.health.check([
      () => this.db.pingCheck('database'),
      () => this.redis.pingCheck('redis'),
    ]);
  }

  @Get('live')
  liveness() {
    return { status: 'ok', timestamp: new Date().toISOString() };
  }
}

// Prometheus Metrics
@Injectable()
export class MetricsService {
  private readonly httpRequestDuration = new Histogram({
    name: 'http_request_duration_seconds',
    help: 'Duration of HTTP requests in seconds',
    labelNames: ['method', 'route', 'status_code'],
  });

  private readonly httpRequestTotal = new Counter({
    name: 'http_requests_total',
    help: 'Total number of HTTP requests',
    labelNames: ['method', 'route', 'status_code'],
  });

  recordHttpRequest(method: string, route: string, statusCode: number, duration: number) {
    this.httpRequestTotal.inc({ method, route, status_code: statusCode.toString() });
    this.httpRequestDuration.observe({ method, route, status_code: statusCode.toString() }, duration);
  }
}
```

## 13. Key Conventions Summary

### 13.1. Architecture Principles
1. **Clean Architecture** v·ªõi t√°ch bi·ªát r√µ r√†ng c√°c layer
2. **CQRS Pattern** ƒë·ªÉ t√°ch bi·ªát Read/Write operations
3. **Dependency Injection** s·ª≠ d·ª•ng NestJS DI container
4. **Repository Pattern** v·ªõi TypeORM
5. **Domain-Driven Design** v·ªõi business logic trong entities

### 13.2. Code Quality Standards
1. **TypeScript strict mode** enabled
2. **ESLint + Prettier** cho code formatting
3. **Jest** cho testing v·ªõi coverage threshold 80%
4. **Docker** cho containerization
5. **Kubernetes** cho orchestration

### 13.3. API Standards
1. **RESTful API** v·ªõi proper HTTP methods
2. **Kong Gateway** integration v·ªõi JWT authentication
3. **Consistent response format** v·ªõi success/error structure
4. **Proper HTTP status codes** mapping
5. **API versioning** v·ªõi `/KONGAPI/api/v1/` prefix

### 13.4. Security Best Practices
1. **Kong JWT Plugin** cho authentication
2. **Role-based authorization** trong NestJS
3. **Input validation** v·ªõi class-validator
4. **SQL injection prevention** v·ªõi TypeORM
5. **HTTPS only** trong production

### 13.5. Performance & Scalability
1. **Database indexing** strategies
2. **Query optimization** v·ªõi TypeORM QueryBuilder
3. **Caching** v·ªõi Redis
4. **Connection pooling** cho database
5. **Horizontal scaling** v·ªõi Kubernetes
```